/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/cell-element-helpers.mjs":
/*!**************************************!*\
  !*** ./src/cell-element-helpers.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"moveDown\": () => (/* binding */ moveDown),\n/* harmony export */   \"moveLeft\": () => (/* binding */ moveLeft),\n/* harmony export */   \"moveRight\": () => (/* binding */ moveRight),\n/* harmony export */   \"moveUp\": () => (/* binding */ moveUp),\n/* harmony export */   \"setCellContent\": () => (/* binding */ setCellContent),\n/* harmony export */   \"toggleClueDirection\": () => (/* binding */ toggleClueDirection)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\n/**\n * **toggleClueDirection** - toggle  the _clue_ direction (across/down).\n * @param {*} crosswordController the DOM associated with thw\n * @param {*} eventCell\n * @returns\n */\nfunction toggleClueDirection(crosswordController, eventCell) {\n  //  If we are in a eventCell with an across clue AND down clue, swap the\n  //  current clue.\n  const swappable = eventCell.acrossClue && eventCell.downClue;\n  if (swappable) {\n    // swap clue direction\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('toggleClueDirection');\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentClue =\n      eventCell.acrossClue === crosswordController.currentClue\n        ? eventCell.downClue\n        : eventCell.acrossClue;\n  }\n  return swappable;\n}\n\nfunction jumpToNextSegment(crosswordController, eventCell) {\n  const clue = crosswordController.currentClue;\n  const currentIndex =\n    eventCell.acrossClue === clue\n      ? eventCell.acrossClueLetterIndex\n      : eventCell.downClueLetterIndex;\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`jumpToNextSegment: current cell index: ${currentIndex}`);\n  const nextIndex = currentIndex + 1;\n  //  If we are at the end of the clue and we have a next segment, select it.\n  const jumpable = nextIndex === clue.cells.length && clue.nextClueSegment;\n  if (jumpable) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('Focussing next answer segment cell index 0');\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentClue = clue.nextClueSegment;\n  }\n  return jumpable;\n}\n\nfunction jumpToPreviousSegment(crosswordController, eventCell) {\n  const clue = crosswordController.currentClue;\n  const currentIndex =\n    eventCell.acrossClue === clue\n      ? eventCell.acrossClueLetterIndex\n      : eventCell.downClueLetterIndex;\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`moveUp: current cell index: ${currentIndex}`);\n  const previousIndex = currentIndex - 1;\n  //  If we are at the start of the clue and we have a previous segment, select it.\n  const jumpable = previousIndex === -1 && clue.previousClueSegment;\n  if (jumpable) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('moveUp: Focussing prev answer segment last cell');\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = last(clue.previousClueSegment.cells);\n  }\n  return jumpable;\n}\n\nfunction moveDown(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n  const { height } = eventCell.model;\n\n  let moved = false;\n\n  if (\n    eventCell.y + 1 < height &&\n    eventCell.model.cells[x][y + 1].light === true\n  ) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x][y + 1];\n    moved = true;\n  } else {\n    // Can we go to next segment in clue?\n    moved = jumpToNextSegment(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction moveRight(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n  const { width } = eventCell.model;\n\n  let moved = false;\n\n  if (\n    eventCell.x + 1 < width &&\n    eventCell.model.cells[x + 1][y].light === true\n  ) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x + 1][y];\n    moved = true;\n  } else {\n    // Can we go to next segment in clue?\n    moved = jumpToNextSegment(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction moveUp(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n\n  let moved = false;\n\n  if (eventCell.y > 0 && eventCell.model.cells[x][y - 1].light === true) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x][y - 1];\n    moved = true;\n  } else {\n    // Can we go to previous segment in clue?\n    moved = jumpToPreviousSegment(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction moveLeft(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n  let moved = false;\n\n  if (eventCell.x > 0 && eventCell.model.cells[x - 1][y].light === true) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x - 1][y];\n    moved = true;\n  } else {\n    // Can we go to previous segment in clue?\n    moved = jumpToPreviousSegment(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction setCellContent(crosswordController, event, character) {\n  const eventCell = crosswordController.cell(event.target.parentNode);\n  //  eslint-disable-next-line no-param-reassign\n  event.target.value = character;\n\n  //  We need to update the answers\n  if (eventCell.acrossClue) {\n    eventCell.acrossClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(\n      eventCell.acrossClue.answer,\n      eventCell.acrossClueLetterIndex,\n      character,\n    );\n  }\n  // across and/or down are possible\n  if (eventCell.downClue) {\n    eventCell.downClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(\n      eventCell.downClue.answer,\n      eventCell.downClueLetterIndex,\n      character,\n    );\n  }\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/cell-element-helpers.mjs?");

/***/ }),

/***/ "./src/cell-map.mjs":
/*!**************************!*\
  !*** ./src/cell-map.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CellMap\": () => (/* binding */ CellMap)\n/* harmony export */ });\n//  Internally used map of Crossword model data to DOM elements.\nclass CellMap {\n  #map;\n  constructor() {\n    this.#map = [];\n  }\n\n  //  Adds a Cell <-> Cell Element mapping.\n  add(cell, cellElement) {\n    this.#map.push({\n      cell,\n      cellElement,\n    });\n  }\n\n  //  Gets the DOM element for a cell.\n  getCellElement(cell) {\n    const mapping = this.#map.find((x) => x.cell === cell);\n    return mapping ? mapping.cellElement : null;\n  }\n\n  //  Gets the cell for a DOM element.\n  getCell(cellElement) {\n    const mapping = this.#map.find((x) => x.cellElement === cellElement);\n    return mapping ? mapping.cell : null;\n  }\n\n  //  Removes entries for a crossword.\n  removeCrosswordCells(crossword) {\n    this.#map = this.#map.filter((x) => x.cell.crossword !== crossword);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/cell-map.mjs?");

/***/ }),

/***/ "./src/clue-model.mjs":
/*!****************************!*\
  !*** ./src/clue-model.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cluePattern\": () => (/* binding */ cluePattern),\n/* harmony export */   \"newClueModel\": () => (/* binding */ newClueModel)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n// Parse the groups: /^numberGroup\\.clueGroup\\(answerGroup\\)$/\nconst clueRegex = /^(.*?)\\.(.*)\\((.*?)\\)$/;\n// Parse numberGroup into 1+ clue segment labels\nconst numberGroupRegex = /^(\\d+[ad]?)(,(\\d+[ad]?.*))*$/;\n// Parse clueGroup from surrounding whitespace\nconst clueGroupRegex = /^\\s*(.*?)\\s*$/;\n// Parse answerGroup into 1+ single-word or multi-word lengths\nconst answerGroupRegex = /^(\\d+)(([,-])(\\d+.*))*$/;\n\nconst cluePattern = '<NumberText>.<ClueText>(<AnswerText>)';\n\n//  Helper for newClueModel()\nfunction validateClueStructure(cdClue) {\n  const required = { x: 1, y: 1, clue: '1. Clue (1)' };\n  const optional = { answer: '', solution: '', revealed: '' };\n  const requiredKeys = Object.keys(required);\n  const optionalKeys = Object.keys(optional);\n  const cdKeys = Object.keys(cdClue);\n\n  // Test for presence of required keys\n  for (const rk of requiredKeys) {\n    if (!cdKeys.includes(rk)) throw new Error(`'cdClue.${rk}' is missing`);\n  }\n\n  // Test for type of required keys\n  for (const rk of requiredKeys) {\n    if (typeof required[rk] != typeof cdClue[rk]) {\n      throw new Error(\n        `'cdClue.${rk} (${cdClue[rk]})' must be a ${typeof required[rk]}`,\n      );\n    }\n  }\n\n  // Test for presence and type of optional keys\n  for (const ok of optionalKeys) {\n    if (cdKeys.includes(ok) && typeof optional[ok] != typeof cdClue[ok])\n      throw new Error(\n        `'cdClue.${ok} (${cdClue[ok]})' must be a ${typeof optional[ok]}`,\n      );\n  }\n\n  // Test for additional properties in cdClue\n\n  const difference = new Set(cdKeys);\n  for (const rk of requiredKeys) {\n    difference.delete(rk);\n  }\n  for (const ok of optionalKeys) {\n    difference.delete(ok);\n  }\n\n  if (difference.size > 0) {\n    throw new Error(\n      `'cdClue' has unexpected properties <${[...difference].join(',')}>`,\n    );\n  }\n\n  // Test if clue text matches expected pattern\n  if (!clueRegex.test(cdClue.clue)) {\n    throw new Error(\n      `Clue '${cdClue.clue}' does not match the required pattern '${cluePattern}'`,\n    );\n  }\n}\n\n//  Helper for newClueModel()\nfunction validateClueModelArguments(cdClue, isAcrossClue) {\n  if (cdClue === undefined || isAcrossClue === undefined) {\n    throw new Error(\"'cdClue' and 'isAcrossClue' are required\");\n  }\n\n  if (cdClue === null) {\n    throw new Error(\"'cdClue' can't be null\");\n  }\n\n  if (isAcrossClue === null) {\n    throw new Error(\"'isAcrossClue' can't be null\");\n  }\n\n  if (typeof isAcrossClue != 'boolean') {\n    throw new Error(\"'isAcrossClue' must be a boolean (true,false)\");\n  }\n}\n\n// Helper for newClueModel()\nfunction buildClueLabelSegments(clueLabelText, cdClue) {\n  let remainingText = clueLabelText;\n  let clueLabelSegments = [];\n  while (numberGroupRegex.test(remainingText)) {\n    // Discard leading \",\" before residual\n    const [, labelSegment, , residual] = numberGroupRegex.exec(remainingText);\n    clueLabelSegments.push(labelSegment);\n    remainingText = residual;\n  }\n\n  if (remainingText != undefined) {\n    throw new Error(\n      `'${cdClue.clue}' Error in <numberText> near <${remainingText}>`,\n    );\n  }\n  return clueLabelSegments;\n}\n\n// Helper for newClueModel()\nfunction buildConnectedDirectedClues(clueLabelSegments) {\n  // Helper\n  function directionFromClueLabel(clueLabel) {\n    if (clueLabel.endsWith('a')) {\n      return 'across';\n    } else if (clueLabel.endsWith('d')) {\n      return 'down';\n    } else {\n      return null;\n    }\n  }\n\n  let connectedSegments = clueLabelSegments.slice(1);\n  let connectedDirectedClues = [];\n\n  // build connected clues\n  if (connectedSegments) {\n    connectedDirectedClues = connectedSegments.map((cs) => ({\n      number: parseInt(cs, 10),\n      direction: directionFromClueLabel(cs),\n    }));\n  }\n  return connectedDirectedClues;\n}\n\n// Helper for newClueModel()\nfunction buildAnswerSegments(answerGroup, cdClue) {\n  let answerSegments = [];\n  let remainingText = answerGroup;\n\n  while (answerGroupRegex.test(remainingText)) {\n    const [, length, , terminator, residual] =\n      answerGroupRegex.exec(remainingText);\n    answerSegments.push({\n      length: parseInt(length, 10),\n      terminator: terminator ?? '',\n    });\n    remainingText = residual;\n  }\n\n  if (remainingText != undefined) {\n    throw new Error(\n      `'${cdClue.clue}' Error in <answerText> near <${remainingText}>`,\n    );\n  }\n  return answerSegments;\n}\n\n/**\n * Create a clue model from a clue read from a\n * _CrosswordDefinition_ [JSON](https://en.wikipedia.org/wiki/JSON) document.\n * @param cdClue - an object which defines the clue, with properties:\n * x: the zero-based grid column index of the starting letter of the clue\n * y: the zero-based grid row index of the starting letter of the clue\n * clue: the clue description string which has the format:\n *   \"<Number Structure>.<Clue>(<Answer Structure>)\"\n * @param isAcrossClue - a boolean indicating the clue orientation\n * @returns - the clue model for the given definition\n */\nfunction newClueModel(cdClue, isAcrossClue) {\n  // Test for null or undefined argument\n  validateClueModelArguments(cdClue, isAcrossClue);\n  // Test the properties and types of the cdClue argument\n  validateClueStructure(cdClue);\n\n  // Extract simple properties\n  const x = cdClue.x - 1; //  Definitions are 1 based, models are more useful 0 based.\n  const y = cdClue.y - 1;\n\n  const isAcross = isAcrossClue;\n  // Initialise array of crossword grid elements - populated as part of crossword DOM\n  const cells = [];\n  // Initialise setter's solution for clue\n  const solution = cdClue.solution\n    ? // Strip out everything from solution except alphabetical characters\n      // DO NOT substitute spaces\n      cdClue.solution.toUpperCase().replaceAll(/[^A-Z]/g, '')\n    : undefined;\n  // Initialise revealed letters for clue\n  const revealed = cdClue.revealed\n    ? // string of upper-cased revealed characters\n      cdClue.revealed.toUpperCase()\n    : undefined;\n\n  //  Get the clue components.\n  const [, numberGroup, clueGroup, answerGroup] = clueRegex.exec(cdClue.clue);\n\n  //// Parse numberGroup\n\n  const clueLabelSegments = buildClueLabelSegments(numberGroup, cdClue);\n  const connectedDirectedClues = buildConnectedDirectedClues(clueLabelSegments);\n\n  const anchorSegment = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.first)(clueLabelSegments);\n  const number = parseInt(anchorSegment, 10);\n  const clueLabel = number.toString();\n\n  // Code is number followed by 'a' or 'd'...\n  // Check last character of anchorSegment and append if required\n\n  const code =\n    anchorSegment.endsWith('a') || anchorSegment.endsWith('d')\n      ? anchorSegment\n      : anchorSegment + (isAcrossClue ? 'a' : 'd');\n\n  //// Parse clueGroup\n\n  const [, clueText] = clueGroupRegex.exec(clueGroup);\n\n  //// Parse answerGroup\n\n  const answerSegments = buildAnswerSegments(answerGroup, cdClue);\n\n  //  Calculate the total length of the answer.\n  const answerLength = answerSegments.reduce(\n    (current, as) => current + as.length,\n    0,\n  );\n\n  // trace(`cdClue.answer: <${cdClue.answer}>`);\n  // Initialise punter's answer for clue\n  const answer = cdClue.answer\n    ? cdClue.answer\n        // convert to uppercase\n        .toUpperCase()\n        // replace illegal characters with spaces\n        .replaceAll(/[^ A-Z]/g, ' ')\n        // pad out if required\n        .padEnd(answerLength)\n    : // pad out null or undefined answer with spaces\n      ''.padEnd(answerLength);\n  // trace(`newClueModel: answer:<${answer}> solution:<${solution}>`);\n\n  //  Also create the answer segments as text.\n  const answerLengthText = `(${answerGroup})`;\n\n  // Test if clue solution length matches answerLength\n  if (solution && solution.length !== answerLength) {\n    throw new Error(\n      `Length of clue solution '${solution}' does not match the answer length '${answerLengthText}'`,\n    );\n  }\n\n  // Test if clue revealed length matches answerLength\n  if (revealed && revealed.length !== answerLength) {\n    throw new Error(\n      `Length of clue revealed characters '${revealed}' does not match the answer length: ${answerLength}`,\n    );\n  }\n\n  // Combine elements into object and exit\n  return {\n    answer,\n    answerLength,\n    answerLengthText,\n    answerSegments,\n    cells,\n    clueLabel,\n    clueText,\n    code,\n    connectedDirectedClues,\n    isAcross,\n    number,\n    revealed,\n    solution,\n    x,\n    y,\n  };\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/clue-model.mjs?");

/***/ }),

/***/ "./src/crossword-controller-helpers.mjs":
/*!**********************************************!*\
  !*** ./src/crossword-controller-helpers.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Outcome\": () => (/* binding */ Outcome),\n/* harmony export */   \"anchorSegmentClues\": () => (/* binding */ anchorSegmentClues),\n/* harmony export */   \"checkSolved\": () => (/* binding */ checkSolved),\n/* harmony export */   \"cleanClue\": () => (/* binding */ cleanClue),\n/* harmony export */   \"cleanCrossword\": () => (/* binding */ cleanCrossword),\n/* harmony export */   \"hideElement\": () => (/* binding */ hideElement),\n/* harmony export */   \"resetClue\": () => (/* binding */ resetClue),\n/* harmony export */   \"resetCrossword\": () => (/* binding */ resetCrossword),\n/* harmony export */   \"revealCell\": () => (/* binding */ revealCell),\n/* harmony export */   \"revealClue\": () => (/* binding */ revealClue),\n/* harmony export */   \"revealCrossword\": () => (/* binding */ revealCrossword),\n/* harmony export */   \"showElement\": () => (/* binding */ showElement),\n/* harmony export */   \"testClue\": () => (/* binding */ testClue),\n/* harmony export */   \"testCrossword\": () => (/* binding */ testCrossword)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\nconst hideElement = (element) => {\n  element && element.classList.add('hidden');\n};\nconst showElement = (element) => {\n  element && element.classList.remove('hidden');\n};\n\n// Helper function to filter single-segment and anchor-segment clues\n// from clue array\nconst anchorSegmentClues = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.memoize)((clues) => {\n  return clues.filter((x) => !x.previousClueSegment);\n});\n\nfunction revealCell(controller, cell) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n  // trace(`revealCell:(${cell.x},${cell.y})`);\n  const clue = cell.acrossClue ? cell.acrossClue : cell.downClue;\n  const letterIndex = cell.acrossClue\n    ? cell.acrossClueLetterIndex\n    : cell.downClueLetterIndex;\n  const solutionLetter = clue.solution[letterIndex];\n  // trace(`revealCell: solution:${clue.solution},letterIndex:${letterIndex})`);\n  const clearRevealed = false;\n  setCellText(controller, cell, solutionLetter, clearRevealed);\n  // set visual flag in cell that letter has been revealed\n  showElement(controller.revealedElement(cell));\n  // clear visual flag in cell if letter was incorrect\n  hideElement(controller.incorrectElement(cell));\n}\n\nfunction revealClue(controller, clue) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`revealClue: '${clue.code}'`);\n  const clues = clue.parentClue\n    ? [clue.parentClue].concat(clue.parentClue.connectedClues)\n    : [clue];\n  clues.forEach((c) => {\n    c.cells.forEach((cell) => {\n      revealCell(controller, cell);\n    });\n  });\n}\n\nfunction revealCrossword(controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('revealCrossword');\n  controller.crosswordModel.cells.forEach((row) => {\n    row\n      .filter((x) => x.light)\n      .forEach((cell) => {\n        revealCell(controller, cell);\n      });\n  });\n}\n\nconst Outcome = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.newEnum)([\n  'Correct', // 0 elements empty, N elements correct\n  'Incorrect', // 1+ elements incorrect\n  'Incomplete', // 1+ elements empty, 0 elements incorrect\n]);\n\nfunction testCell(controller, cell, showIncorrect = true) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n\n  // Get index of cell-letter in clue\n  // Cell can be in across and/or down clue\n  const [clue, letterIndex] = cell.acrossClue\n    ? [cell.acrossClue, cell.acrossClueLetterIndex]\n    : [cell.downClue, cell.downClueLetterIndex];\n  const answerLetter = clue.answer[letterIndex];\n  const solutionLetter = clue.solution[letterIndex];\n  const outcome =\n    answerLetter === solutionLetter\n      ? Outcome.Correct\n      : answerLetter === ' ' || answerLetter === undefined\n      ? Outcome.Incomplete\n      : Outcome.Incorrect;\n  // trace(\n  //   `testCell(${cell.x},${cell.y}): [${answerLetter}] [${solutionLetter}] ${outcome}`\n  // );\n\n  if (outcome === Outcome.Incorrect && showIncorrect) {\n    // set visual flag in cell that answer letter is incorrect\n    showElement(controller.incorrectElement(cell));\n  }\n  return outcome;\n}\n\nfunction testClue(controller, clue, showIncorrect = true) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`testClue: '${clue.code}'`);\n\n  let incorrect = 0,\n    incomplete = 0;\n  const clues = clue.parentClue\n    ? [clue.parentClue].concat(clue.parentClue.connectedClues)\n    : [clue];\n  clues.forEach((c) => {\n    // short-circuit an incorrect result`- use find()\n    c.cells.forEach((cell) => {\n      const outcome = testCell(controller, cell, showIncorrect);\n      if (outcome === Outcome.Incorrect) {\n        incorrect += 1;\n        // trace(`incorrect: ${incorrect}`);\n      } else if (outcome === Outcome.Incomplete) {\n        incomplete += 1;\n        // trace(`incomplete: ${incomplete}`);\n      }\n    });\n  });\n  return incorrect > 0\n    ? Outcome.Incorrect\n    : incomplete > 0\n    ? Outcome.Incomplete\n    : Outcome.Correct;\n}\n\nfunction testCrossword(controller, showIncorrect = true) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  // trace('testCrossword');\n  let incorrect = 0,\n    incomplete = 0;\n  controller.crosswordModel.cells.forEach((row) => {\n    row\n      .filter((x) => x.light)\n      .forEach((cell) => {\n        const outcome = testCell(controller, cell, showIncorrect);\n        if (outcome === Outcome.Incorrect) {\n          incorrect += 1;\n          // trace(`incorrect: ${incorrect}`);\n        } else if (outcome === Outcome.Incomplete) {\n          incomplete += 1;\n          // trace(`incomplete: ${incomplete}`);\n        }\n      });\n  });\n\n  return incorrect > 0\n    ? Outcome.Incorrect\n    : incomplete > 0\n    ? Outcome.Incomplete\n    : Outcome.Correct;\n}\n\nfunction checkSolved(controller) {\n  // trace('checkSolved');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  let incorrect = 0,\n    incomplete = 0;\n  const showIncorrect = false;\n  // short-circuit a non-correct result - use find()\n  controller.crosswordModel.cells.find((row) => {\n    return row\n      .filter((x) => x.light)\n      .find((cell) => {\n        const outcome = testCell(controller, cell, showIncorrect);\n        if (outcome === Outcome.Incorrect) {\n          incorrect = 1;\n          // trace(`incorrect: ${incorrect}`);\n          return true;\n        } else if (outcome === Outcome.Incomplete) {\n          incomplete = 1;\n          // trace(`incomplete: ${incomplete}`);\n          return true;\n        }\n      });\n  });\n\n  return incorrect > 0\n    ? Outcome.Incorrect\n    : incomplete > 0\n    ? Outcome.Incomplete\n    : Outcome.Correct;\n}\n\nfunction setCellText(controller, cell, newText, clearRevealed) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(\n    cell && (cell.acrossClue || cell.downClue),\n    'setCellText: cell is null or not part of a clue',\n  );\n\n  function adjustClue(clue, letterIndex) {\n    let result = clue;\n    result.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(result.answer, letterIndex, newText);\n    if (clearRevealed) {\n      result.revealed = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(result.revealed, letterIndex, newText);\n    }\n    return result;\n  }\n  // Cell can be part of BOTH across and down clues\n\n  // Outcome for across clue\n  if (cell.acrossClue) {\n    let clue = cell.acrossClue;\n    // get index of cell-letter in clue\n    const letterIndex = cell.acrossClueLetterIndex;\n    // set stored values\n    clue = adjustClue(clue, letterIndex);\n  }\n\n  // Outcome for down clue\n  if (cell.downClue) {\n    let clue = cell.downClue;\n    // get index of cell-letter in clue\n    const letterIndex = cell.downClueLetterIndex;\n    // set stored values\n    clue = adjustClue(clue, letterIndex);\n  }\n  // eslint-disable-next-line no-param-reassign\n  controller.inputElement(cell).value = newText;\n}\n\nfunction resetCell(controller, cell) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n  // trace(`resetCell:(${cell.x},${cell.y})`);\n\n  const clearRevealed = true;\n  // put a space in the cell\n  setCellText(controller, cell, ' ', clearRevealed);\n  // remove visual flags in cell\n  hideElement(controller.incorrectElement(cell));\n}\n\nfunction resetClue(controller, clue) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`resetClue: '${clue.code}'`);\n\n  const clues = clue.parentClue\n    ? [clue.parentClue].concat(clue.parentClue.connectedClues)\n    : [clue];\n  clues.forEach((c) => {\n    c.cells.forEach((cell) => {\n      resetCell(controller, cell);\n    });\n  });\n}\n\nfunction resetCrossword(controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('resetCrossword');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  controller.crosswordModel.cells.forEach((row) => {\n    row\n      .filter((x) => x.light)\n      .forEach((cell) => {\n        resetCell(controller, cell);\n      });\n  });\n}\n\nfunction cleanCell(controller, cell) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n  // trace(`cleanCell:(${cell.x},${cell.y})`);\n\n  const wrongLetter = testCell(controller, cell) === Outcome.Incorrect;\n  const clearRevealed = wrongLetter;\n  // is the current cell letter incorrect?\n  if (wrongLetter) {\n    setCellText(controller, cell, ' ', clearRevealed);\n    // remove visual flags in cell\n    hideElement(controller.incorrectElement(cell));\n  }\n}\n\nfunction cleanClue(controller, clue) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`cleanClue: '${clue.code}'`);\n  const clues = clue.parentClue\n    ? [clue.parentClue].concat(clue.parentClue.connectedClues)\n    : [clue];\n  clues.forEach((c) => {\n    c.cells.forEach((cell) => {\n      cleanCell(controller, cell);\n    });\n  });\n}\n\nfunction cleanCrossword(controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('cleanCrossword');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  controller.crosswordModel.cells.forEach((row) => {\n    row\n      .filter((x) => x.light)\n      .forEach((cell) => {\n        cleanCell(controller, cell);\n      });\n  });\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-controller-helpers.mjs?");

/***/ }),

/***/ "./src/crossword-controller.mjs":
/*!**************************************!*\
  !*** ./src/crossword-controller.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CrosswordController\": () => (/* binding */ CrosswordController)\n/* harmony export */ });\n/* harmony import */ var _cell_map_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell-map.mjs */ \"./src/cell-map.mjs\");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n/* harmony import */ var _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crossword-controller-helpers.mjs */ \"./src/crossword-controller-helpers.mjs\");\n/* harmony import */ var _cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cell-element-helpers.mjs */ \"./src/cell-element-helpers.mjs\");\n\n\n\n\n\n// Keycode values\nconst BACKSPACE = 8,\n  TAB = 9,\n  ENTER = 13,\n  LEFT = 37,\n  UP = 38,\n  RIGHT = 39,\n  DOWN = 40,\n  DELETE = 46;\n\n// Regular expressions for keypress processing.\n// All pressed keys are upper-cased before testing.\nconst echoingKeyPressCharacters = /^[A-Z]$/;\nconst advancingKeyPressCharacters = /^[ A-Z]$/;\n\n// Allow DOM event flushing after clue or crossword solution.\nconst SOLUTION_TIMEOUT = 5;\n\n/** **CrosswordController** - an [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)\n * _Controller_ class for the _CrosswordsJS_ package.\n * Use this class to access the package API.\n */\nclass CrosswordController {\n  #cellMap = new _cell_map_mjs__WEBPACK_IMPORTED_MODULE_0__.CellMap();\n  #current = { clue: null, cell: null };\n  #pubSub = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.newPubSub)();\n  #subscribers = [];\n  #crosswordGridView;\n  #crosswordCluesView;\n  #crosswordModel;\n  #domGridParentElement;\n  #domCluesParentElement;\n  #userEventHandlers;\n\n  // Events published by the CrosswordController\n  #controllerEventNames = [\n    'cellRevealed',\n    'clueCleaned',\n    'clueReset',\n    'clueRevealed',\n    'clueSelected',\n    'clueSolved',\n    'clueTested',\n    'crosswordCleaned',\n    'crosswordReset',\n    'crosswordRevealed',\n    'crosswordSolved',\n    'crosswordTested',\n  ];\n\n  constructor(crosswordModel, domGridParentElement, domCluesParentElement) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('CrosswordController constructor');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(\n      crosswordModel,\n      'CrosswordController: crosswordModel is null or undefined',\n    );\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(\n      domGridParentElement,\n      'CrosswordController: domGridParentElement is null or undefined',\n    );\n    this.#crosswordModel = crosswordModel;\n    this.#domGridParentElement = domGridParentElement;\n    this.#domCluesParentElement = domCluesParentElement;\n    //  Build the DOM for the crossword grid.\n    this.#crosswordGridView = this.#document.createElement('div');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(this.#crosswordGridView, 'crossword-grid');\n\n    // Build the DOM for the crossword clues.\n    if (domCluesParentElement) {\n      this.#crosswordCluesView = this.#newCrosswordCluesView(\n        this.#document,\n        this,\n      );\n      //  Add the crossword clues to the webpage DOM\n      domCluesParentElement.appendChild(this.#crosswordCluesView);\n    }\n\n    //  Create each cell.\n    for (let y = 0; y < this.#crosswordModel.height; y += 1) {\n      for (let x = 0; x < this.#crosswordModel.width; x += 1) {\n        const cell = this.#crosswordModel.cells[x][y];\n\n        //  Build the cell element and add it to the row.\n        const cellElement = this.#newCellElement(this.#document, cell);\n        this.#crosswordGridView.appendChild(cellElement);\n\n        //  Update the map of cells\n        this.#cellMap.add(cell, cellElement);\n      }\n    }\n\n    // Mapping of end-user-initiated events to handler methods\n    this.#userEventHandlers = {\n      // Reveal solution for current letter in answer. All revealed cells have\n      // distinct styling which remains for the duration of the puzzle.\n      // Public shaming is strictly enforced!\n      'reveal-cell': this.revealCurrentCell,\n      // Remove incorrect letters in the answer after testing.\n      'clean-clue': this.cleanCurrentClue,\n      // Clear out the answer for the current clue\n      'reset-clue': this.resetCurrentClue,\n      // Reveal solution for current clue\n      'reveal-clue': this.revealCurrentClue,\n      // Test the current clue answer against the solution. Incorrect letters\n      // have distinct styling which is removed when 'cleared' or a new letter\n      // entered in the cell.\n      'test-clue': this.testCurrentClue,\n      // Clear out all incorrect letters in the entire crossword\n      'clean-crossword': this.cleanCrossword,\n      // Clear out the entire crossword\n      'reset-crossword': this.resetCrossword,\n      // Reveal solutions for the entire crossword.\n      'reveal-crossword': this.revealCrossword,\n      // Test the answers for the entire crossword against the solutions\n      'test-crossword': this.testCrossword,\n    };\n\n    //  Add the crossword grid to the webpage DOM\n    this.#domGridParentElement.appendChild(this.crosswordGridView);\n\n    // Select the first \"across\" clue when the grid is complete and visible.\n    this.currentClue = this.#crosswordModel.acrossClues[0];\n  }\n\n  //  Completely cleans up the crossword.\n  destroy() {\n    //  Clear the map, DOM and state change handler.\n    this.#cellMap.removeCrosswordCells(this.#crosswordModel);\n    this.#domGridParentElement.removeChild(this.crosswordGridView);\n    this.#domCluesParentElement.removeChild(this.crosswordCluesView);\n    this.#subscribers.forEach((s) => {\n      s.remove();\n    });\n  }\n\n  // Helper function to retrieve corresponding cell for cellElement\n  cell = (cellElement) => {\n    return this.#cellMap.getCell(cellElement);\n  };\n\n  // Helper function to retrieve corresponding cellElement for cell\n  cellElement = (cell) => {\n    return this.#cellMap.getCellElement(cell);\n  };\n\n  // Helper function to retrieve corresponding inputElement for cell\n  inputElement = (cell) => {\n    // The input element of a cellElement is the first child element.\n    // Refer to #newCellElement()\n    return this.cellElement(cell).children[0];\n  };\n\n  // Helper function to retrieve corresponding revealedElement for cell\n  revealedElement = (cell) => {\n    // The revealed element of a cellElement is the second or third child element.\n    // Refer to #newCellElement()\n    const childIndex = cell.clueLabel ? 2 : 1;\n    return this.cellElement(cell).children[childIndex];\n  };\n  // Helper function to retrieve corresponding incorrectElement for cell\n  incorrectElement = (cell) => {\n    // The incorrect element of a cellElement is the third or fourth child element.\n    // Refer to #newCellElement()\n    const childIndex = cell.clueLabel ? 3 : 2;\n    return this.cellElement(cell).children[childIndex];\n  };\n\n  // Helper function to access API event handler functions\n  userEventHandler(id) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`elementEventHandler:${id}`);\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(\n      this.#userEventHandlers.hasOwnProperty(id),\n      `userEventHandler: [${id}] is not a CrosswordController event handler.`,\n    );\n    // We dereference userEventHandlers object like an array to get property 'id'\n    // We bind the controller object as the context for 'this' references in the event handler,\n    // otherwise event.currentTarget is the context\n    return this.#userEventHandlers[id].bind(this);\n  }\n\n  get userEventHandlerIds() {\n    return Object.keys(this.#userEventHandlers);\n  }\n\n  // Helper function to bind Controller user-event-handler to webpage\n  // DOM elementId.\n  bindEventHandlerToId = function (\n    elementId,\n    eventName = 'click',\n    dom = document,\n  ) {\n    const element = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.eid)(elementId, dom);\n    if (element) {\n      element.addEventListener(eventName, this.userEventHandler(elementId));\n    }\n  }.bind(this);\n\n  // Helper function to bind Controller user-event-handlers to a collection\n  // of webpage DOM elementIds.\n  bindEventHandlersToIds = function (\n    // all controller user event handlers\n    elementIds = this.userEventHandlerIds,\n    eventName = 'click',\n    dom = document,\n  ) {\n    elementIds.forEach((id) => {\n      this.bindEventHandlerToId(id, eventName, dom);\n    });\n  }.bind(this);\n\n  // Helper function to bind Controller user-event-handler to webpage\n  // DOM element class. Using element class names rather than element Ids\n  // allows us to add controller user-event-handler to more than one\n  // DOM element\n  bindEventHandlerToClass = function (\n    elementClass,\n    eventName = 'click',\n    dom = document,\n  ) {\n    const elements = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.ecs)(elementClass, dom);\n    elements.forEach((e) => {\n      e.addEventListener(eventName, this.userEventHandler(elementClass));\n    });\n  }.bind(this);\n\n  // Helper function to bind Controller user-event-handlers to a collection\n  // of webpage DOM elementIds.\n  bindEventHandlersToClass = function (\n    // all user event handlers\n    elementClasses = this.userEventHandlerIds,\n    eventName = 'click',\n    dom = document,\n  ) {\n    elementClasses.forEach((ec) =>\n      this.bindEventHandlerToClass(ec, eventName, dom),\n    );\n  }.bind(this);\n\n  // Accessors for public property currentCell\n  get currentCell() {\n    return this.#current.cell;\n  }\n  set currentCell(cell) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`set currentCell: (${cell.x},${cell.y})`);\n    if (cell !== this.#current.cell) {\n      if (this.#current.cell) {\n        this.#deHighlightCell(this.#current.cell);\n      }\n      this.#current.cell = cell;\n      cell?.cellElement.children[0].focus();\n      this.#highlightCell(cell);\n    }\n  }\n\n  // Accessors for public property currentClue\n  get currentClue() {\n    return this.#current.clue;\n  }\n  set currentClue(clue) {\n    if (clue !== this.#current.clue) {\n      if (this.#current.clue) {\n        this.#deactivateClue(this.#current.clue);\n      }\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`set currentClue: '${clue.code}'`);\n      this.#current.clue = clue;\n      this.#activateClue(clue);\n      // check if new current clue includes current cell\n      if (!this.currentClue.cells.includes(this.currentCell)) {\n        // switch to first cell of new current clue\n        this.currentCell = this.currentClue.cells[0];\n      }\n      this.#stateChange('clueSelected', clue);\n    }\n  }\n\n  // Accessor for crosswordModel\n  get crosswordModel() {\n    return this.#crosswordModel;\n  }\n\n  // Accessors for public event publisher\n  get addEventsListener() {\n    return this.#addEventsListener;\n  }\n\n  // Accessor for crosswordGridView\n  get crosswordGridView() {\n    return this.#crosswordGridView;\n  }\n\n  // Accessor for crosswordCluesView\n  get crosswordCluesView() {\n    return this.#crosswordCluesView;\n  }\n\n  // Accessor for controllerEventNames\n  get controllerEventNames() {\n    return this.#controllerEventNames;\n  }\n\n  //// methods ////\n\n  testCurrentClue() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`testCurrentClue:${this.currentClue.code}`);\n    const showIncorrect = true;\n    const outcome = (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.testClue)(this, this.currentClue, showIncorrect);\n    this.#stateChange('clueTested', outcome);\n    if (outcome === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.Correct) {\n      // allow other events to complete before the tadah! moment\n      setTimeout(() => {\n        this.#stateChange('clueSolved', this.currentClue);\n      }, SOLUTION_TIMEOUT);\n    }\n    return outcome;\n  }\n\n  testCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('testCrossword');\n    const showIncorrect = true;\n    // call the crossword-controller-helper testCrossword\n    const outcome = (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.testCrossword)(this, showIncorrect);\n    this.#stateChange('crosswordTested', outcome);\n    if (outcome === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.Correct) {\n      // allow other events to complete before the tadah! moment\n      setTimeout(() => {\n        this.#stateChange('crosswordSolved', this.crosswordModel);\n      }, SOLUTION_TIMEOUT);\n    }\n    return outcome;\n  }\n\n  revealCurrentCell() {\n    // trace('revealCurrentCell');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.revealCell)(this, this.currentCell);\n    this.#stateChange('cellRevealed', this.currentCell);\n    this.#checkSolved();\n  }\n\n  revealCurrentClue() {\n    // trace('revealCurrentClue');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.revealClue)(this, this.currentClue);\n    this.#stateChange('clueRevealed', this.currentClue);\n    this.#checkSolved();\n  }\n\n  revealCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('revealCrossword');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.revealCrossword)(this);\n    this.#stateChange('crosswordRevealed', this.crosswordModel);\n    //No crossword solved notification\n  }\n\n  resetCurrentClue() {\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.resetClue)(this, this.currentClue);\n    this.#stateChange('clueReset', this.currentClue);\n  }\n\n  resetCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('resetCrossword');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.resetCrossword)(this);\n    this.#stateChange('crosswordReset', this.crosswordModel);\n  }\n\n  cleanCurrentClue() {\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.cleanClue)(this, this.currentClue);\n    this.#stateChange('clueCleaned', this.currentClue);\n  }\n\n  cleanCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('cleanCrossword');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.cleanCrossword)(this);\n    this.#stateChange('crosswordCleaned', this.crosswordModel);\n  }\n\n  //// Private methods ////\n\n  // Accessor for document associated with DOM\n  get #document() {\n    return this.#domGridParentElement.ownerDocument;\n  }\n  // Accessor for window associated with DOM\n  get #window() {\n    return this.#document.defaultView;\n  }\n\n  // Helper function to subscribe to CrosswordController events.\n  // Refer to #controllerEventNames for complete list of events.\n  #addEventsListener = (eventNames, callback) => {\n    eventNames.forEach((en) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(\n        this.controllerEventNames.includes(en),\n        `addEventsListener: event [${en}] is not a CrosswordController event.`,\n      );\n      this.#subscribers.push(this.#pubSub.subscribe(en, callback));\n    });\n  };\n\n  #currentClueChanged(eventCell) {\n    const across = eventCell.acrossClue;\n    const down = eventCell.downClue;\n    let context;\n    const previousClue = this.currentClue;\n\n    //  If we have clicked somewhere which is part of the current clue, we\n    //  will not need to change it (we won't toggle either).\n    if (\n      this.currentClue &&\n      (this.currentClue === across || this.currentClue === down)\n    ) {\n      context = 'in CurrentClue';\n    } else if ((across && !down) || (!across && down)) {\n      //  If we have an across clue XOR a down clue, pick the one we have.\n      this.currentClue = across || down;\n      context = `${this.currentClue === across ? 'across' : 'down'} (xor)`;\n    } else if (\n      across &&\n      this.currentClue &&\n      (across === this.currentClue.previousClueSegment ||\n        across === this.nextClueSegment)\n    ) {\n      //  We've got across. If we are moving between clue segments,\n      //  prefer to choose the next/previous segment...\n      this.currentClue = across;\n      context = 'across (multi-segment)';\n    } else if (\n      down &&\n      this.currentClue &&\n      (down === this.currentClue.previousClueSegment ||\n        down === this.nextClueSegment)\n    ) {\n      //  We've got down. If we are moving between clue segments,\n      //  prefer to choose the next/previous segment...\n      this.currentClue = down;\n      context = 'down (multi-segment)';\n    } else {\n      //  ...otherwise, Prefer across, unless we're on the first letter of a down clue only\n      this.currentClue =\n        eventCell.downClueLetterIndex === 0 &&\n        eventCell.acrossClueLetterIndex !== 0\n          ? down\n          : across;\n      context = `${\n        this.currentClue === across ? 'across' : 'down'\n      } (first letter of down only or default across)`;\n    }\n\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`currentClueChanged: ${context}`);\n    return this.currentClue !== previousClue;\n  }\n\n  /**\n   * **#stateChange**: Publish crossword events to the handler allocated/subscribed to _onStateChange_.\n   * @param {*} message The name of the event to be published\n   * @param {*} data not used\n   */\n  #stateChange(message, data) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`stateChange: ${message}`);\n    this.#pubSub.publish(message, data);\n  }\n\n  #checkSolved() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('checkSolved');\n    if ((0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.checkSolved)(this) === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.Correct) {\n      // allow other events to complete before the tadah! moment\n      setTimeout(() => {\n        this.#stateChange('crosswordSolved', this.crosswordModel);\n      }, SOLUTION_TIMEOUT);\n    }\n  }\n\n  /**\n   * **newCrosswordCluesView**: build a crossword clues DOM element\n   * with separate blocks for across and down clues.\n   * @param {*} document the root node of the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model#DOM_tree_structure)\n   * @param {*} controller the crossword controller object\n   * @returns the clues DOM element\n   */\n  #newCrosswordCluesView(document, controller) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('newCrosswordCluesView');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(document, '#newCrosswordCluesView: [document] is null or undefined');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(\n      controller,\n      '#newCrosswordCluesView: [controller] is null or undefined',\n    );\n\n    function newClueBlockElement(id, title) {\n      let cbElement = document.createElement('div');\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(cbElement, 'crossword-clue-block');\n      cbElement.id = id;\n      let titleElement = document.createElement('p');\n      titleElement.innerHTML = title;\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(titleElement, 'crossword-clue-block-title');\n      cbElement.appendChild(titleElement);\n      return cbElement;\n    }\n\n    function addClueElements(controller, clueBlockElement, cluesModel) {\n      cluesModel.forEach((mc) => {\n        let clueElement = document.createElement('div');\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(clueElement, 'crossword-clue');\n        clueElement.modelClue = mc;\n\n        let labelElement = document.createElement('span');\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(labelElement, 'crossword-clue-label');\n        labelElement.innerHTML = `${mc.clueLabel}`;\n        clueElement.appendChild(labelElement);\n\n        let textElement = document.createElement('span');\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(textElement, 'crossword-clue-text');\n        textElement.innerHTML = `${mc.clueText} ${mc.answerLengthText}`;\n        clueElement.appendChild(textElement);\n\n        // add handler for click event\n        clueElement.addEventListener('click', (element) => {\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`clue(${mc.clueLabel}):click`);\n          // eslint-disable-next-line no-param-reassign\n          controller.currentClue = mc;\n        });\n        clueBlockElement.appendChild(clueElement);\n      });\n    }\n\n    function isCurrentClueSegment(clue) {\n      const currentClue = controller.currentClue;\n\n      // The trivial case is that the clue is selected.\n      if (clue === currentClue) {\n        return true;\n      } else {\n        //  We might also be a clue which is part of a multi-segment clue.\n        const parentClue = currentClue?.parentClue;\n\n        return (\n          currentClue &&\n          parentClue &&\n          (parentClue === clue ||\n            parentClue.connectedClues.indexOf(clue) !== -1)\n        );\n      }\n    }\n\n    // Build the DOM for the crossword clues.\n    let view = {\n      wrapper: document.createElement('div'),\n      acrossClues: newClueBlockElement('crossword-across-clues', 'Across'),\n      downClues: newClueBlockElement('crossword-down-clues', 'Down'),\n    };\n\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(view.wrapper, 'crossword-clues');\n\n    addClueElements(\n      controller,\n      view.acrossClues,\n      controller.crosswordModel.acrossClues,\n    );\n    view.wrapper.appendChild(view.acrossClues);\n\n    addClueElements(\n      controller,\n      view.downClues,\n      controller.crosswordModel.downClues,\n    );\n    view.wrapper.appendChild(view.downClues);\n\n    // Handle when current clue has changed in controller\n    // eslint-disable-next-line no-param-reassign\n    controller.addEventsListener(['clueSelected'], (data) => {\n      for (const vac of view.acrossClues.children) {\n        if (isCurrentClueSegment(vac.modelClue)) {\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(vac, 'current-clue-segment');\n        } else {\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.removeClass)(vac, 'current-clue-segment');\n        }\n      }\n\n      for (const vdc of view.downClues.children) {\n        if (isCurrentClueSegment(vdc.modelClue)) {\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(vdc, 'current-clue-segment');\n        } else {\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.removeClass)(vdc, 'current-clue-segment');\n        }\n      }\n    });\n\n    return view.wrapper;\n  }\n\n  // Helper function for #newCellElement()\n  #addEventListeners(cellElement, inputElement) {\n    const controller = this;\n    //  Listen for focus events.\n    inputElement.addEventListener('focus', (event) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('event:focus');\n      //  Get the cell data.\n      const eventCell = controller.cell(event.target.parentNode);\n      if (controller.#currentClueChanged(eventCell)) {\n        this.#stateChange('clueSelected', controller.currentClue);\n      }\n    });\n\n    //  Listen for click events.\n    inputElement.addEventListener('click', (event) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('event:click');\n      const eventCell = controller.cell(event.target.parentNode);\n      // Test for second click on same cell\n      if (eventCell === controller.currentCell) {\n        (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toggleClueDirection)(controller, eventCell);\n      }\n      controller.currentCell = eventCell;\n    });\n\n    //  Listen for keydown events.\n    cellElement.addEventListener('keydown', (event) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`event:keydown keycode=${event.keyCode}`);\n\n      //  Get the cell element and cell data.\n      const eventCell = controller.cell(event.target.parentNode);\n      const { model } = eventCell;\n      let clue = controller.currentClue;\n\n      switch (event.keyCode) {\n        case BACKSPACE:\n          //  We don't want default behaviour.\n          event.preventDefault();\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('BACKSPACE');\n          // Fill cell with SPACE\n          (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setCellContent)(controller, event, ' ');\n          // remove any visual flag in cell that letter is incorrect\n          (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.hideElement)(controller.incorrectElement(eventCell));\n\n          const letterIndex =\n            eventCell.acrossClue === clue\n              ? eventCell.acrossClueLetterIndex\n              : eventCell.downClueLetterIndex;\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`BACKSPACE: current cell index: ${letterIndex}`);\n          const previousIndex = letterIndex - 1;\n\n          if (previousIndex >= 0) {\n            // Move to previous character\n            (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`Focussing previous cell index: ${previousIndex}`);\n            controller.currentCell = clue.cells[previousIndex];\n          } else if (previousIndex === -1 && clue.previousClueSegment) {\n            //  If we are at the start of the clue and we have a previous segment, select it.\n            (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('Focussing previous segment last cell');\n            controller.currentCell = last(clue.previousClueSegment.cells);\n          }\n\n          break;\n\n        case TAB:\n          //  We don't want default behaviour.\n          event.preventDefault();\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('TAB');\n\n          // get anchor segment of multi-segment clue\n          if (clue.parentClue) {\n            clue = clue.parentClue;\n          }\n          // Get the next clue.\n          // Skip clues which are part of a multi-segment clue and not the anchor segment.\n          const searchClues = clue.isAcross\n            ? (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.anchorSegmentClues)(model.acrossClues)\n            : (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.anchorSegmentClues)(model.downClues);\n\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(\n            `tab: across (${clue.isAcross}) searchClues.length (${searchClues.length})`,\n          );\n\n          let newClue = null;\n          const sci = searchClues.indexOf(clue);\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(\n            sci !== -1,\n            `keydown(TAB): clue '${clue.code}' not found in searchClues`,\n          );\n\n          if (event.shiftKey) {\n            //  Shift-tab selects previous clue\n            if (sci > 0) {\n              // Selects previous clue in same direction if not the first clue\n              newClue = searchClues[sci - 1];\n            } else {\n              // On first clue, wrap to last clue in other direction\n              newClue = clue.isAcross\n                ? model.downClues[model.downClues.length - 1]\n                : model.acrossClues[model.acrossClues.length - 1];\n            }\n          } else if (sci < searchClues.length - 1) {\n            // Tab selects next clue in same direction if not the last clue\n            newClue = searchClues[sci + 1];\n          } else {\n            // On last clue, tab wraps to first clue in other direction\n            newClue = clue.isAcross ? model.downClues[0] : model.acrossClues[0];\n          }\n\n          // Select the new clue.\n          controller.currentClue = newClue;\n\n          break;\n\n        case ENTER:\n          //  We don't want default behaviour.\n          event.preventDefault();\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('ENTER');\n          (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toggleClueDirection)(controller, eventCell);\n\n          break;\n\n        case DELETE:\n          //  We don't want default behaviour.\n          event.preventDefault();\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('DELETE');\n          // Fill cell with SPACE\n          (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setCellContent)(controller, event, ' ');\n          // remove any visual flag in cell that letter is incorrect\n          (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.hideElement)(controller.incorrectElement(eventCell));\n\n          break;\n\n        default:\n          break;\n      }\n    });\n\n    //  Listen for keypress events.\n    cellElement.addEventListener('keypress', (event) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('event:keypress');\n      // We've just pressed a key that generates a character.\n      // Stop default handling for input component\n      event.preventDefault();\n\n      //  Get cell data.\n      const eventCell = controller.cell(event.target.parentNode);\n      const clue = controller.currentClue;\n\n      // Convert keyCode to upper-case character\n      const character = String.fromCharCode(event.keyCode).toUpperCase();\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`character:<${character}>`);\n\n      if (echoingKeyPressCharacters.test(character)) {\n        //  Sets the letter in the current clue cell.\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`Setting content: <${character}>`);\n        (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setCellContent)(controller, event, character);\n        // remove any visual flag in cell that letter is incorrect\n        (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.hideElement)(controller.incorrectElement(eventCell));\n        // test for crossword completion\n        this.#checkSolved();\n      }\n\n      if (advancingKeyPressCharacters.test(character)) {\n        //  Move to the next cell in the clue.\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('Advancing to next cell');\n        const currentCellIndex =\n          eventCell.acrossClue === clue\n            ? eventCell.acrossClueLetterIndex\n            : eventCell.downClueLetterIndex;\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`current cell index: ${currentCellIndex}`);\n        const nextCellIndex = currentCellIndex + 1;\n\n        if (nextCellIndex < clue.cells.length) {\n          // We are still within the bounds of the current clue (segment)\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)(`Focussing next cell index: ${nextCellIndex}`);\n          controller.currentCell = clue.cells[nextCellIndex];\n        } else if (clue.nextClueSegment) {\n          //  We are at the end of the clue segment and there is a next segment.\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('Focussing next answer segment cell index 0');\n          controller.currentClue = clue.nextClueSegment;\n        }\n      }\n    });\n\n    //  Listen for keyup events.\n    cellElement.addEventListener('keyup', (event) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('event:keyup');\n      const eventCell = controller.cell(event.target.parentNode);\n\n      switch (event.keyCode) {\n        case LEFT:\n          (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.moveLeft)(controller, eventCell);\n          break;\n        case UP:\n          (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.moveUp)(controller, eventCell);\n          break;\n        case RIGHT:\n          (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.moveRight)(controller, eventCell);\n          break;\n        case DOWN:\n          (0,_cell_element_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.moveDown)(controller, eventCell);\n          break;\n        //  No action needed for any other keys.\n        default:\n          break;\n      }\n    });\n  }\n\n  /**\n   * **newCellElement**: build a crossword grid _cell_ DOM element\n   * with child elements and event listeners to handle user interaction events.\n   * @param {*} document the root node of the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model#DOM_tree_structure)\n   * @param {*} cell the representation of this grid cell in the  _crosswordModel_.\n   * @returns the DOM element for the _cell_\n   */\n  #newCellElement(document, cell) {\n    // trace(`newCellElement(${cell.x},${cell.y})`);\n    const cellElement = document.createElement('div');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(cellElement, 'cwcell');\n    //  eslint-disable-next-line no-param-reassign\n    cell.cellElement = cellElement;\n\n    //  Add a class.\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(cellElement, cell.light ? 'light' : 'dark');\n\n    //  If the cell is dark, we are done.\n    if (!cell.light) {\n      return cellElement;\n    }\n\n    //  Light cells also need an input.\n    const inputElement = document.createElement('input');\n    inputElement.maxLength = 1;\n    if (cell.answer) {\n      inputElement.value = cell.answer;\n    }\n    cellElement.appendChild(inputElement);\n\n    //  We may need to add a clue label.\n    if (cell.clueLabel) {\n      const clueLabel = document.createElement('div');\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(clueLabel, 'cwclue-label');\n      clueLabel.innerHTML = cell.clueLabel;\n      cellElement.appendChild(clueLabel);\n    }\n\n    const revealedIndicator = document.createElement('div');\n    // Remove 'hidden' div class to reveal\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClasses)(revealedIndicator, ['cwcell-revealed', 'hidden']);\n    cellElement.appendChild(revealedIndicator);\n\n    const incorrectIndicator = document.createElement('div');\n    // Toggle 'hidden' div class to reveal/hide\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClasses)(incorrectIndicator, ['cwcell-incorrect', 'hidden']);\n    cellElement.appendChild(incorrectIndicator);\n\n    //  Check for clue answer segment terminator.\n    if (',-'.includes(cell.acrossTerminator)) {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(inputElement, 'cw-across-word-separator');\n    } else if (',-'.includes(cell.downTerminator)) {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(inputElement, 'cw-down-word-separator');\n    }\n\n    //// Event handlers\n    this.#addEventListeners(cellElement, inputElement);\n    return cellElement;\n  }\n\n  #activateClue(clue) {\n    //  Highlight the clue cells. 'parentClue' is set if this is the later part of\n    //  a multi-segment clue.\n    const clues = clue.parentClue\n      ? [clue.parentClue].concat(clue.parentClue.connectedClues)\n      : [clue];\n    clues.forEach((c) => {\n      c.cells.forEach((cell) => {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(this.inputElement(cell), 'active');\n      });\n    });\n  }\n\n  #deactivateClue(clue) {\n    //  Highlight the clue cells. 'parentClue' is set if this is the later part of\n    //  a multi-segment clue.\n    const clues = clue.parentClue\n      ? [clue.parentClue].concat(clue.parentClue.connectedClues)\n      : [clue];\n    clues.forEach((c) => {\n      c.cells.forEach((cell) => {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.removeClass)(this.inputElement(cell), 'active');\n      });\n    });\n  }\n\n  #highlightCell(cell) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(cell, '#highLightCell: cell is undefined');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('#highlightCell');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.addClass)(this.inputElement(cell), 'highlighted');\n  }\n\n  #deHighlightCell(cell) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.trace)('#deHighlightCell');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.assert)(cell, '#deHighLightCell: cell is undefined');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.removeClass)(this.inputElement(cell), 'highlighted');\n  }\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-controller.mjs?");

/***/ }),

/***/ "./src/crossword-model.mjs":
/*!*********************************!*\
  !*** ./src/crossword-model.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"newCrosswordModel\": () => (/* binding */ newCrosswordModel)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n/* harmony import */ var _clue_model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clue-model.mjs */ \"./src/clue-model.mjs\");\n\n\n\n// Helper for newCrosswordModel()\nfunction buildCellGrid(crosswordModel) {\n  const { width } = crosswordModel;\n  const { height } = crosswordModel;\n  const array = new Array(width);\n  for (let across = 0; across < width; across += 1) {\n    array[across] = new Array(height);\n    for (let down = 0; down < height; down += 1) {\n      array[across][down] = {\n        model: crosswordModel,\n        x: across,\n        y: down,\n      };\n    }\n  }\n  return array;\n}\n\n// Helper for newCrosswordModel()\n// Find the segment of an answer a specific letter is in.\nfunction getAnswerSegment(answerSegments, letterIndex) {\n  let remainingIndex = letterIndex;\n  for (const as of answerSegments) {\n    if (remainingIndex <= as.length) {\n      return [as, remainingIndex];\n    }\n\n    remainingIndex -= as.length;\n  }\n\n  return null;\n}\n\n// Helper for newCrosswordModel()\nfunction initialiseCrosswordModel(crosswordDefinition) {\n  let crosswordModel = {\n    width: crosswordDefinition.width,\n    height: crosswordDefinition.height,\n    acrossClues: [],\n    downClues: [],\n    cells: [],\n  };\n  if (\n    crosswordModel.width === undefined ||\n    crosswordModel.width === null ||\n    crosswordModel.width < 0 ||\n    crosswordModel.height === undefined ||\n    crosswordModel.height === null ||\n    crosswordModel.height < 0\n  ) {\n    throw new Error('The crossword bounds are invalid.');\n  }\n  return crosswordModel;\n}\n\n// Helper for newCrosswordModel()\nfunction validateClueInCrossword(clueModel, crosswordModel, isAcrossClue) {\n  if (\n    clueModel.x < 0 ||\n    clueModel.x >= crosswordModel.width ||\n    clueModel.y < 0 ||\n    clueModel.y >= crosswordModel.height\n  ) {\n    throw new Error(`Clue ${clueModel.code} doesn't start in the bounds.`);\n  }\n\n  //  Make sure the clue is not too long.\n  if (isAcrossClue) {\n    if (clueModel.x + clueModel.answerLength > crosswordModel.width) {\n      throw new Error(`Clue ${clueModel.code} exceeds horizontal bounds.`);\n    }\n    // down clue\n  } else if (clueModel.y + clueModel.answerLength > crosswordModel.height) {\n    throw new Error(`Clue ${clueModel.code} exceeds vertical bounds.`);\n  }\n}\n\n// Helper for newCrosswordModel()\nfunction updateOrthogonalClue(cell, character, isAcrossClue) {\n  //  eslint-disable-next-line no-param-reassign\n\n  //  We need to update the answers\n  if (!isAcrossClue && cell.acrossClue) {\n    //  eslint-disable-next-line no-param-reassign\n    cell.acrossClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(\n      cell.acrossClue.answer,\n      cell.acrossClueLetterIndex,\n      character,\n    );\n  }\n  if (isAcrossClue && cell.downClue) {\n    //  eslint-disable-next-line no-param-reassign\n    cell.downClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(\n      cell.downClue.answer,\n      cell.downClueLetterIndex,\n      character,\n    );\n  }\n}\n\n/**\n * **newCrosswordModel**: build a crossword model from a crosswordDefinition object.\n * - The function compiles a JSON crossword and emits diagnostic exceptions when errors are encountered.\n * @param {*} crosswordDefinition A javascript Object typically parsed or imported from a crossword description file in JSON or YAML format.\n * @returns a crossword model object\n */\nfunction newCrosswordModel(crosswordDefinition) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('newCrosswordModel');\n  if (!crosswordDefinition) {\n    throw new Error(\n      'The model must be initialised with a JSON crossword definition.',\n    );\n  }\n\n  //  Create the basic crosswordModel structure.\n  let crosswordModel = initialiseCrosswordModel(crosswordDefinition);\n\n  //  Create the array of cells. Each element has a reference back to the crosswordModel\n  //  for convenience.\n  crosswordModel.cells = buildCellGrid(crosswordModel);\n\n  //  We're going to go through the across clues, then the down clues.\n  const cdClues = crosswordDefinition.acrossClues.concat(\n    crosswordDefinition.downClues,\n  );\n  for (let index = 0; index < cdClues.length; index += 1) {\n    //  Grab the clue and build a flag letting us know if we're across or down.\n    const cdClue = cdClues[index];\n    const isAcrossClue = index < crosswordDefinition.acrossClues.length;\n\n    //  Compile the clue model from the crossword definition of the clue\n    const clueModel = (0,_clue_model_mjs__WEBPACK_IMPORTED_MODULE_1__.newClueModel)(cdClue, isAcrossClue);\n    //  Add clue model to crosswordModel clues array.\n    crosswordModel[isAcrossClue ? 'acrossClues' : 'downClues'].push(clueModel);\n\n    //  The clue position must be in the bounds.\n    validateClueInCrossword(clueModel, crosswordModel, isAcrossClue);\n\n    //  We can now mark the cells as light. If the clue has\n    //  an answer (which is optional), we can validate it\n    //  is coherent.\n    let { x, y } = clueModel;\n    const cellDefaultAnswer = ' ';\n    const cellDefaultSolution = ' ';\n    for (let letter = 0; letter < clueModel.answerLength; letter += 1) {\n      const cell = crosswordModel.cells[x][y];\n      cell.light = true;\n      cell[isAcrossClue ? 'acrossClue' : 'downClue'] = clueModel;\n      cell[isAcrossClue ? 'acrossClueLetterIndex' : 'downClueLetterIndex'] =\n        letter;\n      clueModel.cells.push(cell);\n\n      //  Check if we need to add an answer terminator.\n      const [segment, index] = getAnswerSegment(\n        clueModel.answerSegments,\n        letter,\n      );\n      if (index === segment.length - 1 && segment.terminator !== '') {\n        cell[clueModel.isAcross ? 'acrossTerminator' : 'downTerminator'] =\n          segment.terminator;\n      }\n\n      //  If the imported clue has an answer we set it in the cell...\n      if (cdClue.answer) {\n        //  ...but only if it is not different to an existing answer.\n        if (\n          cell.answer &&\n          // We can overwrite any cells that have default value\n          cell.answer !== cellDefaultAnswer &&\n          cell.answer !== clueModel.answer[letter]\n        ) {\n          throw new Error(\n            `Clue ${clueModel.code} answer at (${x + 1},${y + 1}) [${\n              clueModel.answer\n            }[${letter + 1}],${\n              clueModel.answer[letter]\n            }] is not coherent with previous clue (${\n              cell.acrossClue.code\n            }) answer [${cell.acrossClue.answer},${cell.answer}].`,\n          );\n        }\n        // if cell.answer && cell.answer !== ' '\n        cell.answer = clueModel.answer[letter];\n        // check if cell appears in a clue in the other direction\n        updateOrthogonalClue(cell, cell.answer, isAcrossClue);\n      }\n      // no answer in imported clue, insert default if cell is vacant\n      else {\n        // don't clobber an existing value\n        if (!cell.answer) {\n          cell.answer = cellDefaultAnswer;\n        }\n      }\n\n      //  If the imported clue has a solution we set it in the cell...\n      if (cdClue.solution) {\n        //  ...but only if it is NOT different to any existing solution.\n        if (\n          cell.solution &&\n          // We can overwrite any cells that have the default value\n          cell.solution !== cellDefaultSolution &&\n          cell.solution !== clueModel.solution[letter]\n        ) {\n          throw new Error(\n            `Clue ${clueModel.code} solution at (${x + 1},${y + 1}) [${\n              clueModel.solution\n            }[${letter + 1}],${\n              clueModel.solution[letter]\n            }] is not coherent with previous clue (${\n              cell.acrossClue.code\n            }) solution [${cell.acrossClue.solution},${cell.solution}].`,\n          );\n        }\n        // if (cell.solution && cell.solution !== ' '\n        cell.solution = clueModel.solution[letter];\n      }\n      // no solution in imported clue\n      else {\n        // insert default value (space ' ')\n        cell.solution = cellDefaultSolution;\n      }\n\n      if (letter === 0) {\n        if (cell.clueLabel && cell.clueLabel !== clueModel.number) {\n          throw new Error(\n            `Clue ${clueModel.code} has a label which is inconsistent with another clue (${cell.acrossClue.code}).`,\n          );\n        }\n        cell.clueLabel = clueModel.number;\n      }\n\n      if (isAcrossClue) {\n        x += 1;\n      } else {\n        y += 1;\n      }\n    }\n  }\n\n  //  Now that we have constructed the full crosswordModel,\n  //  we will connect the multi-segment clues.\n  const allClues = crosswordModel.acrossClues.concat(crosswordModel.downClues);\n  allClues.forEach((clue) => {\n    //  Skip clues without a connected clue.\n    if (!clue.connectedDirectedClues) return;\n\n    //  Find the connected clues.\n    //  eslint-disable-next-line no-param-reassign\n    clue.connectedClues = clue.connectedDirectedClues.map((cdc) => {\n      if (cdc.direction === 'across') {\n        return crosswordModel.acrossClues.find(\n          (ac) => ac.number === cdc.number,\n        );\n      }\n      if (cdc.direction === 'down') {\n        return crosswordModel.downClues.find((dc) => dc.number === cdc.number);\n      }\n      return (\n        crosswordModel.acrossClues.find((ac) => ac.number === cdc.number) ||\n        crosswordModel.downClues.find((dc) => dc.number === cdc.number)\n      );\n    });\n\n    //  Rebuild the answer structure text.\n    //  eslint-disable-next-line no-param-reassign\n    clue.answerLengthText = `(${[clue.answerLengthText]\n      .concat(clue.connectedClues.map((cc) => cc.answerLengthText))\n      .join(',')\n      .replace(/[()]/g, '')})`;\n\n    //  Each clue should know its parent 'master clue' as well as the next and\n    //  previous clue segments.\n    let clueSegmentIndex = 0;\n    const clueSegments = [clue].concat(clue.connectedClues);\n    clueSegments.forEach((cs) => {\n      if (clueSegmentIndex > 0) {\n        //  eslint-disable-next-line no-param-reassign\n        cs.previousClueSegment = clueSegments[clueSegmentIndex - 1];\n      }\n      if (clueSegmentIndex < clueSegments.length - 1) {\n        //  eslint-disable-next-line no-param-reassign\n        cs.nextClueSegment = clueSegments[clueSegmentIndex + 1];\n      }\n      //  eslint-disable-next-line no-param-reassign\n      [cs.parentClue] = clueSegments;\n      clueSegmentIndex += 1;\n    });\n\n    //  Create the master clue label.\n    //  eslint-disable-next-line no-param-reassign\n    clue.clueLabel = `${[clue.number]\n      .concat(clue.connectedClues.map((cc) => cc.number))\n      .join(',')}.`;\n\n    //  The connected clues need no answer structure, an indicator they are\n    //  connected clues and a back link to the master clue.\n    clue.connectedClues.forEach((cc) => {\n      //  eslint-disable-next-line no-param-reassign\n      cc.answerLengthText = null; // we just show the answer structure for the first clue\n      //  eslint-disable-next-line no-param-reassign\n      cc.isConnectedClue = true; // makes it easier to render these clues differently\n    });\n  });\n\n  return crosswordModel;\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-model.mjs?");

/***/ }),

/***/ "./src/helpers.mjs":
/*!*************************!*\
  !*** ./src/helpers.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addClass\": () => (/* binding */ addClass),\n/* harmony export */   \"addClasses\": () => (/* binding */ addClasses),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"ecs\": () => (/* binding */ ecs),\n/* harmony export */   \"eid\": () => (/* binding */ eid),\n/* harmony export */   \"first\": () => (/* binding */ first),\n/* harmony export */   \"last\": () => (/* binding */ last),\n/* harmony export */   \"memoize\": () => (/* binding */ memoize),\n/* harmony export */   \"newEnum\": () => (/* binding */ newEnum),\n/* harmony export */   \"newPubSub\": () => (/* binding */ newPubSub),\n/* harmony export */   \"removeClass\": () => (/* binding */ removeClass),\n/* harmony export */   \"replaceStrAt\": () => (/* binding */ replaceStrAt),\n/* harmony export */   \"setLetter\": () => (/* binding */ setLetter),\n/* harmony export */   \"toHexString\": () => (/* binding */ toHexString),\n/* harmony export */   \"toggleClass\": () => (/* binding */ toggleClass),\n/* harmony export */   \"trace\": () => (/* binding */ trace),\n/* harmony export */   \"tracing\": () => (/* binding */ tracing)\n/* harmony export */ });\n// Lightweight helper functions.\n\n/**\n * **addClass** - add a [CSS](https://en.wikipedia.org/wiki/CSS) class to a\n * [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) element.\n * @param {*} element the element (object reference)\n * @param {*} className the class to add (string)\n */\nfunction addClass(element, className) {\n  element.classList.add(className);\n}\nfunction addClasses(element, classNames) {\n  classNames.forEach((cn) => {\n    element.classList.add(cn);\n  });\n}\n\n/**\n * **assert** - logical constraint testing\n * @param condition - test expression (boolean)\n * @param message - (string) recorded on test failure - _condition_ evaluates to `false`.\n */\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\n//// Shortcut functions\n\nconst eid = (elementId, dom = document) => {\n  // trace(`eid: elementId=${elementId}, dom=${dom}`);\n  return dom.getElementById(elementId);\n};\n\n// Returns an array of elements\nconst ecs = (elementClass, dom = document) => {\n  return dom.getElementsByClassName(elementClass);\n};\n\n/**\n * **first** - get the first element of an array\n * @param {*} array\n * @returns the first element of _array_ or null for empty,undefined or null array\n */\nfunction first(array) {\n  // If array is not nullish, return first element\n  return array ? array[0] : null;\n}\n\n/**\n * replaceStrAt - overlay **str** onto **original** string starting at **index**\n * @param original - the string to be mutated\n * @param index - the index of _original_ to start the overlay. Negative values supported like `string.slice()`.\n * @param str - the overlaying text\n * @returns the mutated _original_. Any null or undefined arguments returns _original_.\n * _index_ outside range [0,_original_.length) returns _original_.\n */\nfunction replaceStrAt(original, index, str) {\n  let result = original;\n  if (original && index != null && str) {\n    let pos = parseInt(index, 10);\n    if (pos < 0) {\n      // Normalise negative index values\n      pos = original.length + pos;\n    }\n    if (pos >= 0 && str && original.length > pos) {\n      result = `${original.slice(0, pos)}${str}${original.slice(\n        pos + str.length,\n      )}`;\n    }\n  }\n  return result;\n}\n\n/**\n * **last** - get the last element of an array\n * @param {*} array\n * @returns the last element of _array_ or null for empty,undefined or null array\n */\nfunction last(array) {\n  // If array is not nullish, return last element\n  return array ? array.slice(-1) : null;\n}\n\n/**\n * **memoize** - wrap an arbitrary, single-argument,\n * [idempotent](https://en.wikipedia.org/wiki/Idempotence)\n * function with result-caching.\n * Useful for [_expensive_](https://en.wikipedia.org/wiki/Analysis_of_algorithms) functions.\n * @param {*} fn the function to be [memoized](https://en.wikipedia.org/wiki/Memoization)\n * @returns a reference to the wrapped function. Assign this reference to a variable\n * and invoke in the same manner as a function.\n */\nconst memoize = (fn) => {\n  // A hopefully unique object property name/key!\n  const id = 'id_Z?7kQ;x8j!';\n  const cache = {};\n  return (arg) => {\n    if (!arg[id]) {\n      // Attach a random id property to this object\n      //  eslint-disable-next-line no-param-reassign\n      arg[id] = Math.random().toString(16).slice(2);\n    }\n\n    if (!(arg[id] in cache)) {\n      cache[arg[id]] = fn(arg);\n      trace(`memoize:caching id ${arg[id]}`);\n    }\n\n    return cache[arg[id]];\n  };\n};\n\n/**\n * **removeClass** - remove a [CSS](https://en.wikipedia.org/wiki/CSS) class from a\n * [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) element.\n * @param {*} element the element (object reference)\n * @param {*} className the class to add (string)\n */\nfunction removeClass(element, className) {\n  element.classList.remove(className);\n}\n\n/**\n * setLetter - Set the _source_ letter at _index_ to _newLetter_. Pad _source_ if required.\n * @param {*} source string to be modified\n * @param {*} index target position in _source_\n * @param {*} newLetter replacement letter\n * @returns\n */\nfunction setLetter(source, index, newLetter) {\n  let result = source === null || source === undefined ? '' : source;\n  result = result.padEnd(index + 1, ' ');\n  return replaceStrAt(result, index, newLetter);\n}\n\n/**\n * **toggleClass** - _toggle_(add/remove) a [CSS](https://en.wikipedia.org/wiki/CSS) class on a\n * [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) element.\n * @param {*} element the element (object reference)\n * @param {*} className the class to add (string)\n */\nfunction toggleClass(element, className) {\n  element.classList.toggle(className);\n}\n\n/**\n * toHexString - convert an object to a hexadecimal string\n * @param {} obj - object to be converted\n * @returns string of hexadecimal digits\n */\nconst toHexString = (obj) => {\n  // Fails for circular objects\n  return `0x${[...JSON.stringify(obj)]\n    .map((c, i) => str.charCodeAt(i).toString(16))\n    .join('')}`;\n};\n\n// module scope variable to toggle log tracing\nlet tracingEnabled = false;\n\n/**\n * **tracing** - enable or disable console logging\n * @param {*} enabled logging is on/off\n */\nconst tracing = (enabled) => {\n  tracingEnabled = enabled;\n};\n\n/**\n * trace - console logging\n * @param message - string to be logged\n */\nconst trace = (message) => {\n  if (tracingEnabled) console.log(message);\n};\n\n// https://dev.to/adancarrasco/implementing-pub-sub-in-javascript-3l2e\n// Topics should only be modified from the eventRouter itself (return value of newPubSub)\nconst newPubSub = () => {\n  const topics = {};\n  const hOP = topics.hasOwnProperty;\n\n  return {\n    publish: (topic, info) => {\n      // No topics\n      if (!hOP.call(topics, topic)) return;\n\n      // Emit the message to any of the receivers\n      topics[topic].forEach((item) => {\n        // Send any arguments if specified\n        item(info !== undefined ? info : {});\n      });\n    },\n    subscribe: (topic, callback) => {\n      // Create the array of topics if not initialized yet\n      if (!hOP.call(topics, topic)) topics[topic] = [];\n\n      // We define the index where this receiver is stored in the topics array\n      const index = topics[topic].push(callback) - 1;\n\n      // When we subscribe we return an object to later remove the subscription\n      return {\n        remove: () => {\n          delete topics[topic][index];\n        },\n      };\n    },\n  };\n};\n\nfunction newEnum(values) {\n  const enumeration = {};\n  for (const val of values) {\n    enumeration[val] = val;\n  }\n  return Object.freeze(enumeration);\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/helpers.mjs?");

/***/ }),

/***/ "./src/index.mjs":
/*!***********************!*\
  !*** ./src/index.mjs ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CrosswordsJS\": () => (/* binding */ CrosswordsJS)\n/* harmony export */ });\n/* harmony import */ var _crossword_model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crossword-model.mjs */ \"./src/crossword-model.mjs\");\n/* harmony import */ var _crossword_controller_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crossword-controller.mjs */ \"./src/crossword-controller.mjs\");\n\n\n\n//  Define our public API.\nconst CrosswordsJS = {\n  compileCrossword: _crossword_model_mjs__WEBPACK_IMPORTED_MODULE_0__.newCrosswordModel,\n  Controller: _crossword_controller_mjs__WEBPACK_IMPORTED_MODULE_1__.CrosswordController,\n};\n\n//  If we are in the browser, add the API to the global scope.\nif (typeof window !== 'undefined') {\n  window.CrosswordsJS = CrosswordsJS;\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.mjs");
/******/ 	
/******/ })()
;