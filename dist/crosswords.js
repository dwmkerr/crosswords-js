/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/cell-map.mjs":
/*!**************************!*\
  !*** ./src/cell-map.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CellMap\": () => (/* binding */ CellMap)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\n//  Internally used map of Crossword model data to DOM elements.\nclass CellMap {\n  #modelCells = {};\n\n  //  Adds a Cell <-> Cell Element mapping.\n  add(modelCell, cellElement) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(modelCell, 'modelCell is null or undefined');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cellElement, 'cellElement is null or undefined');\n    // cellElement.id set in CrosswordController.#newCellElement()\n    this.#modelCells[cellElement.id] = modelCell;\n  }\n\n  //  Gets the DOM element for a modelCell.\n  cellElement = (modelCell) => {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof modelCell === 'object', 'Cell is not an object');\n    // modelCell.cellElement set in CrosswordController.#newCellElement()\n    return modelCell.cellElement;\n  };\n\n  //  Gets the modelCell for a DOM element.\n  modelCell = (cellElement) => {\n    switch (typeof cellElement) {\n      case 'string':\n        return this.#modelCells[cellElement];\n      case 'object':\n        return this.#modelCells[cellElement.id];\n      default:\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(true, 'Unexpected type for \"cellElement\"');\n        break;\n    }\n  };\n\n  get modelCells() {\n    // this.#modelCells object properties are keyed by modelCell.toString()\n    // Retrieve the array of associated values (modelCell) for the Object keys\n    return Object.values(this.#modelCells);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/cell-map.mjs?");

/***/ }),

/***/ "./src/clue-model.mjs":
/*!****************************!*\
  !*** ./src/clue-model.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"boldAsteriskRegex\": () => (/* binding */ boldAsteriskRegex),\n/* harmony export */   \"boldItalicAsteriskRegex\": () => (/* binding */ boldItalicAsteriskRegex),\n/* harmony export */   \"boldItalicUnderscoreRegex\": () => (/* binding */ boldItalicUnderscoreRegex),\n/* harmony export */   \"boldUnderscoreRegex\": () => (/* binding */ boldUnderscoreRegex),\n/* harmony export */   \"cluePattern\": () => (/* binding */ cluePattern),\n/* harmony export */   \"clueRegex\": () => (/* binding */ clueRegex),\n/* harmony export */   \"clueTextRegex\": () => (/* binding */ clueTextRegex),\n/* harmony export */   \"italicAsteriskRegex\": () => (/* binding */ italicAsteriskRegex),\n/* harmony export */   \"italicUnderscoreRegex\": () => (/* binding */ italicUnderscoreRegex),\n/* harmony export */   \"labelPartsRegex\": () => (/* binding */ labelPartsRegex),\n/* harmony export */   \"lengthPartsRegex\": () => (/* binding */ lengthPartsRegex),\n/* harmony export */   \"newClueModel\": () => (/* binding */ newClueModel),\n/* harmony export */   \"parseMarkdown\": () => (/* binding */ parseMarkdown)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\nconst cluePattern = 'LabelText.ClueText(LengthText)';\n\n// Parse the groups: /^\\s*LabelText\\.ClueText\\(LengthText\\)\\s*$/\n// 'LabelText' is all characters from start up to but excluding the first period '.'.\n// Leading whitespace is ignored.\n// 'ClueText' is all characters after the first period up to but excluding the last\n// the last opening parenthesis '('\n// 'LengthText' is all characters after the last opening parenthesis up to but excluding\n// the last subsequent closing parenthesis ')'. Trailing whitespace is allowed.\nconst clueRegex = /^\\s*(.*?)\\.(.*)\\((.*)\\)\\s*$/;\n// Parse 'labelText' into 1+ clue segment labels: 1+ digits,\n// optionally followed by an 'a' or a 'd'.\n// The labels are separated by any sequence of 1+ non-alphanumeric\n// characters.\nconst labelPartsRegex = /^([^bce-z]*?)(\\d+[ad]?)\\s*(.*)/;\n// Parse 'clueText' from all leading and trailing whitespace\nconst clueTextRegex = /^\\s*(.*?)\\s*$/;\n// Parse 'lengthText' into 1+ whole-numbers.\n// The lengths are separated by any sequence of 1+ non-alphanumeric\n// characters, excluding parentheses.\n// Special case: acronyms\n// Acronym letters can including a trailing period for the last letter.\n// An example is clue 9a, The Age - Cryptic 08/09/2023\n// For example 'BBQ' -> (1.1.1.)\nconst lengthPartsRegex = /^([^a-z()\\d]*?)(\\d+)[\\s.]*(.*)/;\n\n// Refer to design document: ../docs/clue-markup.md\n\n// Clue markdown regular expressions\nconst boldAsteriskRegex = /(.*?)(\\*\\*.+?\\*\\*)(.*)$/;\nconst boldItalicAsteriskRegex = /(.*?)(\\*\\*\\*.+?\\*\\*\\*)(.*)$/;\nconst italicAsteriskRegex = /(.*?)(\\*[^*]+?\\*)(.*)$/;\nconst boldUnderscoreRegex = /(.*?)(__.+?__)(.*)$/;\nconst boldItalicUnderscoreRegex = /(.*?)(___.+?___)(.*)$/;\nconst italicUnderscoreRegex = /(.*?)(_[^_]+?_)(.*)$/;\n\n// Order is significant - decreasing markdown sequence length\n// Do NOT change!\nconst markdownTransforms = [\n  {\n    tag: '***',\n    regex: boldItalicAsteriskRegex,\n    html: { open: '<span class=\"cw-bold cw-italic\">', close: '</span>' },\n  },\n  {\n    tag: '___',\n    regex: boldItalicUnderscoreRegex,\n    html: { open: '<span class=\"cw-bold cw-italic\">', close: '</span>' },\n  },\n  {\n    tag: '**',\n    regex: boldAsteriskRegex,\n    html: { open: '<span class=\"cw-bold\">', close: '</span>' },\n  },\n  {\n    tag: '__',\n    regex: boldUnderscoreRegex,\n    html: { open: '<span class=\"cw-bold\">', close: '</span>' },\n  },\n  {\n    tag: '*',\n    regex: italicAsteriskRegex,\n    html: { open: '<span class=\"cw-italic\">', close: '</span>' },\n  },\n  {\n    tag: '_',\n    regex: italicUnderscoreRegex,\n    html: { open: '<span class=\"cw-italic\">', close: '</span>' },\n  },\n];\n\n/**\n *  Convert any markdown in _text_ to HTML.\n * @param {*} text source string with Markdown, or not!\n * @returns converted string\n */\nfunction parseMarkdown(text) {\n  // Initialise return value\n  let result = text;\n\n  // Iterate through all transforms, modifying result for all matches\n  markdownTransforms.forEach((mt) => {\n    let prelude,\n      match,\n      // Initialise remainder with converted 'text' to date\n      remainder = result;\n\n    // Test for transform match\n    if (mt.regex.test(remainder)) {\n      // Extract matching groups in regex from 'remainder'\n      let groups = mt.regex.exec(remainder);\n      // Reset result\n      result = '';\n      while (groups?.length === 4) {\n        [, prelude, match, remainder] = groups;\n        // Replace opening tag\n        match = match.replace(mt.tag, mt.html.open);\n        // Replace closing tag\n        match = match.replace(mt.tag, mt.html.close);\n        // Append processed text to result\n        result += prelude + match;\n        groups = mt.regex.exec(remainder);\n      }\n      // Append any remainder after matches exhausted\n      result += remainder;\n    }\n  });\n\n  return result;\n}\n\n//  Helper for newClueModel()\nfunction validateClueStructure(cdClue) {\n  const required = { x: 1, y: 1, clue: '1. Clue (1)' };\n  const optional = { answer: '', solution: '', revealed: '' };\n  const requiredKeys = Object.keys(required);\n  const optionalKeys = Object.keys(optional);\n  const cdKeys = Object.keys(cdClue);\n\n  // Test for presence of required keys\n  for (const rk of requiredKeys) {\n    if (!cdKeys.includes(rk)) throw new Error(`'cdClue.${rk}' is missing`);\n  }\n\n  // Test for type of required keys\n  for (const rk of requiredKeys) {\n    if (typeof required[rk] != typeof cdClue[rk]) {\n      throw new Error(\n        `'cdClue.${rk} (${cdClue[rk]})' must be a ${typeof required[rk]}`,\n      );\n    }\n  }\n\n  // Test for presence and type of optional keys\n  for (const ok of optionalKeys) {\n    if (cdKeys.includes(ok) && typeof optional[ok] != typeof cdClue[ok])\n      throw new Error(\n        `'cdClue.${ok} (${cdClue[ok]})' must be a ${typeof optional[ok]}`,\n      );\n  }\n\n  // Test for additional properties in cdClue\n\n  const difference = new Set(cdKeys);\n  for (const rk of requiredKeys) {\n    difference.delete(rk);\n  }\n  for (const ok of optionalKeys) {\n    difference.delete(ok);\n  }\n\n  if (difference.size > 0) {\n    throw new Error(\n      `'cdClue' has unexpected properties <${[...difference].join(',')}>`,\n    );\n  }\n\n  // Test if clue text matches expected pattern\n  if (!clueRegex.test(cdClue.clue)) {\n    throw new Error(\n      `Clue '${cdClue.clue}' does not match the required pattern '${cluePattern}'`,\n    );\n  }\n}\n\n//  Helper for newClueModel()\nfunction validateClueModelArguments(cdClue, isAcrossClue) {\n  if (cdClue === undefined || isAcrossClue === undefined) {\n    throw new Error(\"'cdClue' and 'isAcrossClue' are required\");\n  }\n\n  if (cdClue === null) {\n    throw new Error(\"'cdClue' can't be null\");\n  }\n\n  if (isAcrossClue === null) {\n    throw new Error(\"'isAcrossClue' can't be null\");\n  }\n\n  if (typeof isAcrossClue != 'boolean') {\n    throw new Error(\"'isAcrossClue' must be a boolean (true,false)\");\n  }\n}\n\n// Helper for newClueModel()\nfunction buildClueSegmentLabels(clueLabelText, cdClue) {\n  // Ensure any clue id values use lower case for the trailing 'a' or 'd'.\n  let remainingText = clueLabelText.toLowerCase();\n  let clueSegmentLabels = [];\n  while (labelPartsRegex.test(remainingText)) {\n    // Discard separator between segmentLabel and residual - see labelPartsRegex comments.\n    const [, , segmentLabel, residual] = labelPartsRegex.exec(remainingText);\n    clueSegmentLabels.push(segmentLabel);\n    remainingText = residual;\n  }\n\n  // remainingText should be an empty string ('')\n  if (remainingText) {\n    throw new Error(\n      `'${cdClue.clue}' Error in <LabelText> near <${remainingText}>`,\n    );\n  }\n  return clueSegmentLabels;\n}\n\n// Helper for newClueModel()\nfunction buildTailDescriptors(clueSegmentLabels) {\n  // Nested helper\n  function directionFromClueSegmentLabel(clueSegmentLabel) {\n    if (clueSegmentLabel.endsWith('a')) {\n      return 'across';\n    } else if (clueSegmentLabel.endsWith('d')) {\n      return 'down';\n    } else {\n      return null;\n    }\n  }\n\n  // Copy clueSegmentLabels and remove head/first segment\n  let tailSegmentLabels = clueSegmentLabels.slice(1);\n  let tailDescriptors = [];\n\n  // build tailDescriptors for multi-segment clue\n  if (tailSegmentLabels.length > 0) {\n    tailDescriptors = tailSegmentLabels.map((cs) => ({\n      headNumber: parseInt(cs, 10),\n      direction: directionFromClueSegmentLabel(cs),\n    }));\n  }\n  return tailDescriptors;\n}\n\n// Helper for newClueModel()\nfunction buildWordLengths(lengthParts, cdClue) {\n  let wordLengths = [];\n  let remainingText = lengthParts;\n\n  while (lengthPartsRegex.test(remainingText)) {\n    const [, , length, residual] = lengthPartsRegex.exec(remainingText);\n    wordLengths.push(parseInt(length, 10));\n    remainingText = residual;\n  }\n\n  // remainingText should be an empty string\n  if (remainingText) {\n    throw new Error(\n      `'${cdClue.clue}' Error in <LengthText> near <${remainingText}>`,\n    );\n  }\n  return wordLengths;\n}\n\n// Helper for newClueModel()\nconst getClueId = (headSegmentLabel, isAcrossClue) => {\n  // clueId is headNumber followed by direction suffix ('a' or 'd')...\n  // Check last character of headSegmentLabel and append if required\n  const directionSuffix = (isAcross) => {\n    return isAcross ? 'a' : 'd';\n  };\n  const directionSuffixRegex = /[ad]$/;\n  return directionSuffixRegex.test(headSegmentLabel)\n    ? headSegmentLabel\n    : headSegmentLabel + directionSuffix(isAcrossClue);\n};\n\n/**\n * Create a clue model from a clue read from a\n * _CrosswordDefinition_ [JSON](https://en.wikipedia.org/wiki/JSON) document.\n * @param cdClue - an object which defines the clue, with properties:\n * x: the zero-based grid column index of the starting letter of the clue\n * y: the zero-based grid row index of the starting letter of the clue\n * clue: the clue description string which has the format:\n *   \"<Number Structure>.<Clue>(<Answer Structure>)\"\n * @param isAcrossClue - a boolean indicating the clue orientation\n * @returns - the clue model for the given definition\n */\nfunction newClueModel(cdClue, isAcrossClue) {\n  // Test for null or undefined argument\n  validateClueModelArguments(cdClue, isAcrossClue);\n  // Test the properties and types of the cdClue argument\n  validateClueStructure(cdClue);\n\n  // Initialise array of crossword grid cell elements associated with\n  // clue - populated as part of crossword DOM\n  const cells = [];\n\n  //// Extract simple properties\n\n  const x = cdClue.x - 1; //  Clue labels are 1 based, clue models are more useful 0 based.\n  const y = cdClue.y - 1;\n  const isAcross = isAcrossClue;\n  // Initialise setter's solution for clue\n  const solution = cdClue.solution\n    ? // Strip out everything from solution except alphabetical characters\n      // DO NOT substitute spaces\n      cdClue.solution.toUpperCase().replaceAll(/[^A-Z]/g, '')\n    : undefined;\n  // Initialise revealed letters for clue\n  const revealed = cdClue.revealed\n    ? // string of upper-cased revealed characters\n      cdClue.revealed.toUpperCase()\n    : undefined;\n\n  //  Extract the clue components from the clue text in the crosswordDefinition\n  const [, labelParts, clueGroup, lengthParts] = clueRegex.exec(cdClue.clue);\n\n  //// Parse labelParts\n\n  const clueSegmentLabels = buildClueSegmentLabels(labelParts, cdClue);\n  const tailDescriptors = buildTailDescriptors(clueSegmentLabels);\n  //  headSegmentLabel is first of clueSegmentLabels\n  const [headSegmentLabel] = clueSegmentLabels;\n  const headNumber = parseInt(headSegmentLabel, 10);\n  const labelText = headNumber.toString();\n  const clueId = getClueId(headSegmentLabel, isAcross);\n\n  //// Parse clueGroup\n\n  const [, rawClueText] = clueTextRegex.exec(clueGroup);\n  const clueText = parseMarkdown(rawClueText);\n\n  //// Parse lengthParts\n\n  const lengthText = `(${lengthParts})`;\n  const wordLengths = buildWordLengths(lengthParts, cdClue);\n  //  Calculate the total length of the clue segment.\n  // Sum the lengths of the clue words\n  const segmentLength = wordLengths.reduce((current, wd) => current + wd, 0);\n\n  //// Initialise punter's answer for clue\n\n  const answer = cdClue.answer\n    ? cdClue.answer\n        // convert to uppercase\n        .toUpperCase()\n        // replace illegal characters with spaces\n        .replaceAll(/[^ A-Z]/g, ' ')\n        // pad out if required\n        .padEnd(segmentLength)\n    : // pad out null or undefined answer with spaces\n      ''.padEnd(segmentLength);\n\n  // Test if clue solution length matches segmentLength\n  if (solution && solution.length !== segmentLength) {\n    throw new Error(\n      `Length of clue solution '${solution}' does not match the lengthText '${lengthText}'`,\n    );\n  }\n\n  // Test if clue revealed length matches segmentLength\n  if (revealed && revealed.length !== segmentLength) {\n    throw new Error(\n      `Length of clue revealed characters '${revealed}' does not match the lengthText: ${segmentLength}`,\n    );\n  }\n\n  // Combine elements into object and exit\n  return {\n    answer,\n    cells,\n    clueId,\n    clueText,\n    headNumber,\n    isAcross,\n    labelText,\n    lengthText,\n    revealed,\n    segmentLength,\n    solution,\n    tailDescriptors,\n    wordLengths,\n    x,\n    y,\n    toString: () => {\n      return `${clueId}`;\n    },\n  };\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/clue-model.mjs?");

/***/ }),

/***/ "./src/crossword-cluesview.mjs":
/*!*************************************!*\
  !*** ./src/crossword-cluesview.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"newCrosswordCluesView\": () => (/* binding */ newCrosswordCluesView)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\n/**\n * **newCrosswordCluesView**: build a crossword clues DOM element\n * with separate blocks for across and down clues.\n * @param {*} document the root node of the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model#DOM_tree_structure)\n * @param {*} controller the crossword controller object\n * @returns the clues DOM element\n */\nfunction newCrosswordCluesView(document, controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('newCrosswordCluesView');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(document, '[document] is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '[controller] is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller.model, '[controller.model] is null or undefined');\n  // assert(controller.model.acrossClues,)\n  function newClueBlockElement(id, title) {\n    let cbElement = document.createElement('div');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(cbElement, 'crossword-clue-block');\n    cbElement.id = id;\n    let titleElement = document.createElement('p');\n    titleElement.innerHTML = title;\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(titleElement, 'crossword-clue-block-title');\n    cbElement.appendChild(titleElement);\n    return cbElement;\n  }\n\n  function addClueElements(controller, clueBlockElement, cluesModel) {\n    cluesModel.forEach((mc) => {\n      let clueElement = document.createElement('div');\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(clueElement, 'crossword-clue');\n      clueElement.modelClue = mc;\n\n      let labelElement = document.createElement('span');\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(labelElement, 'crossword-clue-label');\n      labelElement.innerHTML = `${mc.labelText}`;\n      clueElement.appendChild(labelElement);\n\n      let textElement = document.createElement('span');\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(textElement, 'crossword-clue-text');\n      textElement.innerHTML = `${mc.clueText} ${mc.lengthText}`;\n      clueElement.appendChild(textElement);\n\n      // add handler for click event\n      clueElement.addEventListener('click', (element) => {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`clue(${mc.labelText}):click`);\n        // eslint-disable-next-line no-param-reassign\n        controller.lastMoveEvent = 'click';\n        // eslint-disable-next-line no-param-reassign\n        controller.currentClue = mc;\n      });\n      clueBlockElement.appendChild(clueElement);\n    });\n  }\n\n  function isCurrentClueSegment(clue) {\n    const currentClue = controller.currentClue;\n\n    // The trivial case is that the clue is selected.\n    if (clue === currentClue) {\n      return true;\n    } else {\n      //  We might also be a clue which is part of a multi-segment clue.\n      const headSegment = currentClue.headSegment;\n\n      return (\n        headSegment === clue || headSegment.tailSegments.indexOf(clue) !== -1\n      );\n    }\n  }\n\n  // Build the DOM for the crossword clues.\n  let view = {\n    wrapper: document.createElement('div'),\n    acrossClues: newClueBlockElement('crossword-across-clues', 'Across'),\n    downClues: newClueBlockElement('crossword-down-clues', 'Down'),\n  };\n\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(view.wrapper, 'crosswords-js');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(view.wrapper, 'crossword-clues');\n\n  addClueElements(controller, view.acrossClues, controller.model.acrossClues);\n  view.wrapper.appendChild(view.acrossClues);\n\n  addClueElements(controller, view.downClues, controller.model.downClues);\n  view.wrapper.appendChild(view.downClues);\n\n  // Handle when current clue has changed in controller\n  // eslint-disable-next-line no-param-reassign\n  controller.addEventsListener(['clueSelected'], (data) => {\n    for (const vac of view.acrossClues.children) {\n      if (isCurrentClueSegment(vac.modelClue)) {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(vac, 'current-clue-segment');\n      } else {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.removeClass)(vac, 'current-clue-segment');\n      }\n    }\n\n    for (const vdc of view.downClues.children) {\n      if (isCurrentClueSegment(vdc.modelClue)) {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(vdc, 'current-clue-segment');\n      } else {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.removeClass)(vdc, 'current-clue-segment');\n      }\n    }\n  });\n\n  return view.wrapper;\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-cluesview.mjs?");

/***/ }),

/***/ "./src/crossword-controller-helpers.mjs":
/*!**********************************************!*\
  !*** ./src/crossword-controller-helpers.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Outcome\": () => (/* binding */ Outcome),\n/* harmony export */   \"checkSolved\": () => (/* binding */ checkSolved),\n/* harmony export */   \"cleanClue\": () => (/* binding */ cleanClue),\n/* harmony export */   \"cleanCrossword\": () => (/* binding */ cleanCrossword),\n/* harmony export */   \"resetClue\": () => (/* binding */ resetClue),\n/* harmony export */   \"resetCrossword\": () => (/* binding */ resetCrossword),\n/* harmony export */   \"revealCell\": () => (/* binding */ revealCell),\n/* harmony export */   \"revealClue\": () => (/* binding */ revealClue),\n/* harmony export */   \"revealCrossword\": () => (/* binding */ revealCrossword),\n/* harmony export */   \"setCellText\": () => (/* binding */ setCellText),\n/* harmony export */   \"testClue\": () => (/* binding */ testClue),\n/* harmony export */   \"testCrossword\": () => (/* binding */ testCrossword)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n/* harmony import */ var _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crossword-gridview.mjs */ \"./src/crossword-gridview.mjs\");\n\n\n\nfunction revealCell(controller, cell) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n  const clue = cell.acrossClue ? cell.acrossClue : cell.downClue;\n  const letterIndex = cell.acrossClue\n    ? cell.acrossClueLetterIndex\n    : cell.downClueLetterIndex;\n  const solutionLetter =\n    letterIndex < clue.solution?.length ? clue.solution[letterIndex] : ' ';\n  const clearRevealed = false;\n  setCellText(controller, cell, solutionLetter, clearRevealed);\n  // set visual flag in cell that letter has been revealed\n  (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_1__.showElement)(controller.revealedElement(cell));\n  // clear visual flag in cell if letter was incorrect\n  (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_1__.hideElement)(controller.incorrectElement(cell));\n}\n\nfunction revealClue(controller, clue) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`revealClue: '${clue}'`);\n  clue.headSegment.flatCells.forEach((cell) => {\n    revealCell(controller, cell);\n  });\n}\n\nfunction revealCrossword(controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  controller.model.lightCells.forEach((cell) => {\n    revealCell(controller, cell);\n  });\n}\n\nconst Outcome = Object.freeze({\n  correct: 0, // 0 elements empty, N elements correct\n  incorrect: 1, // 1+ elements incorrect\n  incomplete: 2, // 1+ elements empty, 0 elements incorrect\n});\n\nfunction getOutcome(incorrect, incomplete) {\n  if (incorrect) {\n    return Outcome.incorrect;\n  } else if (incomplete) {\n    return Outcome.incomplete;\n  } else {\n    return Outcome.correct;\n  }\n}\n\nfunction testCell(controller, cell, showIncorrect = true) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n\n  // Get index of cell-letter in clue\n  // Cell can be in across and/or down clue\n  const [clue, letterIndex] = cell.acrossClue\n    ? [cell.acrossClue, cell.acrossClueLetterIndex]\n    : [cell.downClue, cell.downClueLetterIndex];\n  const answerLetter = clue.answer[letterIndex];\n  const solutionLetter = clue.solution ? clue.solution[letterIndex] : undefined;\n  const outcome = getOutcome(\n    !(answerLetter === solutionLetter || answerLetter === ' '),\n    answerLetter === ' ' || answerLetter === undefined,\n  );\n\n  if (outcome === Outcome.incorrect && showIncorrect) {\n    // set visual flag in cell that answer letter is incorrect\n    (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_1__.showElement)(controller.incorrectElement(cell));\n  }\n  return outcome;\n}\n\nfunction testClue(controller, clue, showIncorrect = true) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`testClue: '${clue}'`);\n\n  let incorrect = 0,\n    incomplete = 0;\n\n  clue.headSegment.flatCells.forEach((cell) => {\n    const outcome = testCell(controller, cell, showIncorrect);\n    if (outcome === Outcome.incorrect) {\n      incorrect += 1;\n    } else if (outcome === Outcome.incomplete) {\n      incomplete += 1;\n    }\n  });\n\n  return getOutcome(incorrect > 0, incomplete > 0);\n}\n\nfunction testCrossword(controller, showIncorrect = true) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  let incorrect = 0,\n    incomplete = 0;\n\n  controller.model.lightCells.forEach((cell) => {\n    const outcome = testCell(controller, cell, showIncorrect);\n    if (outcome === Outcome.incorrect) {\n      incorrect += 1;\n    } else if (outcome === Outcome.incomplete) {\n      incomplete += 1;\n    }\n  });\n\n  return getOutcome(incorrect > 0, incomplete > 0);\n}\n\nfunction checkSolved(controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  let incorrect = 0,\n    incomplete = 0;\n  const showIncorrect = false;\n  // short-circuit a non-correct result - use find()\n  controller.model.lightCells.find((cell) => {\n    const outcome = testCell(controller, cell, showIncorrect);\n    if (outcome === Outcome.incorrect) {\n      incorrect += 1;\n      return true;\n    } else if (outcome === Outcome.incomplete) {\n      incomplete += 1;\n      return true;\n    }\n  });\n\n  return getOutcome(incorrect > 0, incomplete > 0);\n}\n\nfunction setCellText(controller, cell, newText, clearRevealed = true) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(\n    cell?.acrossClue || cell?.downClue,\n    'cell is null or not part of a clue',\n  );\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(newText?.length === 1, 'newText must be a single character');\n\n  function adjustClue(clue, letterIndex) {\n    let result = clue;\n    result.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(result.answer, letterIndex, newText);\n    if (clearRevealed) {\n      result.revealed = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(result.revealed, letterIndex, newText);\n    }\n  }\n  // Cell can be part of BOTH across and down clues\n\n  // Outcome for across clue\n  if (cell.acrossClue) {\n    let clue = cell.acrossClue;\n    // get index of cell-letter in clue\n    const letterIndex = cell.acrossClueLetterIndex;\n    // set stored values\n    adjustClue(clue, letterIndex);\n  }\n\n  // Outcome for down clue\n  if (cell.downClue) {\n    let clue = cell.downClue;\n    // get index of cell-letter in clue\n    const letterIndex = cell.downClueLetterIndex;\n    // set stored values\n    adjustClue(clue, letterIndex);\n  }\n  // eslint-disable-next-line no-param-reassign\n  controller.inputElement(cell).value = newText;\n}\n\nfunction resetCell(controller, cell, clearRevealed = false) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n\n  // put a space in the cell\n  setCellText(controller, cell, ' ');\n  // remove visual flags in cell\n  (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_1__.hideElement)(controller.incorrectElement(cell));\n  if (clearRevealed) {\n    (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_1__.hideElement)(controller.revealedElement(cell));\n  }\n}\n\nfunction resetClue(controller, clue) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`resetClue: '${clue}'`);\n\n  clue.headSegment.flatCells.forEach((cell) => {\n    resetCell(controller, cell);\n  });\n}\n\nfunction resetCrossword(controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  controller.model.lightCells.forEach((cell) => {\n    const clearRevealed = true;\n    resetCell(controller, cell, clearRevealed);\n  });\n}\n\nfunction cleanCell(controller, cell) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(cell, '<cell> is null or undefined');\n\n  const wrongLetter = testCell(controller, cell) === Outcome.incorrect;\n  const clearRevealed = wrongLetter;\n  // is the current cell letter incorrect?\n  if (wrongLetter) {\n    setCellText(controller, cell, ' ', clearRevealed);\n    // remove visual flags in cell\n    (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_1__.hideElement)(controller.incorrectElement(cell));\n  }\n}\n\nfunction cleanClue(controller, clue) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(clue, '<clue> is null or undefined');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)(`cleanClue: '${clue}'`);\n  clue.headSegment.flatCells.forEach((cell) => {\n    cleanCell(controller, cell);\n  });\n}\n\nfunction cleanCrossword(controller) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('cleanCrossword');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(controller, '<controller> is null or undefined');\n  controller.model.lightCells.forEach((cell) => {\n    cleanCell(controller, cell);\n  });\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-controller-helpers.mjs?");

/***/ }),

/***/ "./src/crossword-controller.mjs":
/*!**************************************!*\
  !*** ./src/crossword-controller.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CrosswordController\": () => (/* binding */ CrosswordController),\n/* harmony export */   \"newCrosswordController\": () => (/* binding */ newCrosswordController)\n/* harmony export */ });\n/* harmony import */ var _cell_map_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell-map.mjs */ \"./src/cell-map.mjs\");\n/* harmony import */ var _crossword_cluesview_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crossword-cluesview.mjs */ \"./src/crossword-cluesview.mjs\");\n/* harmony import */ var _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crossword-controller-helpers.mjs */ \"./src/crossword-controller-helpers.mjs\");\n/* harmony import */ var _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./crossword-gridview.mjs */ \"./src/crossword-gridview.mjs\");\n/* harmony import */ var _crossword_model_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./crossword-model.mjs */ \"./src/crossword-model.mjs\");\n/* harmony import */ var _default_eventbindings_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./default-eventbindings.mjs */ \"./src/default-eventbindings.mjs\");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\n\n\n\n\n\n\n/**\n * Build a new CrosswordController object\n * @param {*} crosswordDefinition A crossword puzzle document imported or parsed to create an Object.\n * @param {*} domGridParentElement The webpage location (DOM element) for the GridView.\n * @param {*} domCluesParentElement The webpage location (DOM element) for the CluesView.\n * @returns A CrosswordController on successful creation, or null on failure.\n */\n\nfunction newCrosswordController(\n  crosswordDefinition,\n  domGridParentElement,\n  domCluesParentElement,\n) {\n  const controller = new CrosswordController(\n    crosswordDefinition,\n    domGridParentElement,\n    domCluesParentElement,\n  );\n  return controller?.isValid ? controller : null;\n}\n\n// Regular expressions for keypress processing.\n// All pressed keys are lower-cased before testing\n//  - see'keypress' event listener\nconst echoingKeyPressCharacters = /^[a-z]$/;\nconst advancingKeyPressCharacters = /^[a-z]$/;\n\n// Allow DOM event flushing after clue or crossword solution.\nconst publicationDelayMs = 5;\n\n/** **CrosswordController** - an [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)\n * _Controller_ class for the _CrosswordsJS_ package.\n * Use this class to access the package API.\n */\nclass CrosswordController {\n  #boundUserEventElements = [];\n  #cellMap = new _cell_map_mjs__WEBPACK_IMPORTED_MODULE_0__.CellMap();\n  #cluesView;\n  #crosswordModel;\n  #current = { clue: null, cell: null };\n  #domCluesParentElement;\n  #domGridParentElement;\n  #gridView;\n  #keyboardEventBindings = {};\n  #lastMoveEvent;\n  #pubSub = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.newPubSub)();\n  #eventSubscribers = [];\n  #userEventHandlers;\n  #isValidController = false;\n\n  // Events published by the CrosswordController\n  #controllerEventNames = [\n    'cellRevealed',\n    'clueCleaned',\n    'clueIncomplete',\n    'clueReset',\n    'clueRevealed',\n    'clueSelected',\n    'clueSolved',\n    'clueTested',\n    'crosswordCleaned',\n    'crosswordIncomplete',\n    'crosswordLoaded',\n    'crosswordReset',\n    'crosswordRevealed',\n    'crosswordSolved',\n    'crosswordTested',\n  ];\n\n  //////////////////////////\n  //// Lifecycle methods\n  //////////////////////////\n\n  constructor(\n    crosswordDefinition,\n    domGridParentElement,\n    domCluesParentElement,\n  ) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('CrosswordController constructor');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n      crosswordDefinition?.width,\n      '[crosswordDefinition] argument is null/undefined or not a crossword definition',\n    );\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n      domGridParentElement?.ownerDocument,\n      '[domGridParentElement] argument is null/undefined or not a DOM element',\n    );\n    // Optional argument but must be valid if provided\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n      !domCluesParentElement || domCluesParentElement.ownerDocument,\n      '[domCluesParentElement] argument is not a DOM element',\n    );\n\n    this.#domGridParentElement = domGridParentElement;\n    this.#domCluesParentElement = domCluesParentElement;\n    // Set keyboard event keyBindings. Must precede gridView construction\n    this.setKeyboardEventBindings([_default_eventbindings_mjs__WEBPACK_IMPORTED_MODULE_5__.defaultKeyDownBinding, _default_eventbindings_mjs__WEBPACK_IMPORTED_MODULE_5__.defaultKeyUpBinding]);\n    // Create model and views\n    this.#isValidController = this.#bindDefinition(crosswordDefinition);\n    if (this.isValid) {\n      // Mapping of DOM idents (ids or classes) to event handler methods\n      this.#mapDomIdentsToUserEventHandlers();\n    }\n  }\n\n  //  Completely cleans up the crossword.\n  destroy() {\n    //  Clear the cellMap, DOM and state change handler.\n    this.#cellMap = null;\n    this.#crosswordModel = null;\n    this.#gridParent?.removeChild(this.gridView);\n    this.#cluesParent?.removeChild(this.cluesView);\n    // Remove all subscribers\n    this.#eventSubscribers.forEach((s) => {\n      s.remove();\n    });\n    // Remove all user event handlers from DOM elements\n    this.#boundUserEventElements.forEach((bl) => {\n      const { element, eventName, handler } = bl;\n      element.removeEventListener(eventName, handler);\n    });\n  }\n\n  //////////////////////////\n  //// Grid element helpers\n  //////////////////////////\n\n  // Helper function to retrieve corresponding cell for cellElement\n  cell = (cellElement) => {\n    return this.#cellMap.modelCell(cellElement);\n  };\n\n  // Helper function to retrieve corresponding cellElement for cell\n  cellElement = (cell) => {\n    return this.#cellMap.cellElement(cell);\n  };\n\n  // Helper function to retrieve corresponding inputElement for cell\n  inputElement = (cell) => {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(cell.light, `dark cell! ${cell}`);\n    // The input element of a cellElement is the first child element.\n    // Refer to #newCellElement()\n    return this.#cellMap.cellElement(cell).children[0];\n  };\n\n  // Helper function to retrieve corresponding revealedElement for cell\n  revealedElement = (cell) => {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(cell.light, `dark cell! ${cell}`);\n    // The revealed element of a cellElement is the second or third child element.\n    // Refer to #newCellElement()\n    const childIndex = cell.labelText ? 2 : 1;\n    return this.#cellMap.cellElement(cell).children[childIndex];\n  };\n\n  // Helper function to retrieve corresponding incorrectElement for cell\n  incorrectElement = (cell) => {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(cell.light, `dark cell! ${cell}`);\n    // The incorrect element of a cellElement is the third or fourth child element.\n    // Refer to #newCellElement()\n    const childIndex = cell.labelText ? 3 : 2;\n    return this.#cellMap.cellElement(cell).children[childIndex];\n  };\n\n  //////////////////////////////////\n  //// User EventHandler binding\n  //////////////////////////////////\n\n  // Helper function to access API event handler functions\n  userEventHandler(id) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`elementEventHandler:${id}`);\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n      this.#userEventHandlers.hasOwnProperty(id),\n      `[${id}] is not a CrosswordController event handler.`,\n    );\n    // We dereference userEventHandlers object like an array to get property 'id'.\n    // Note: 'this' inside an event handler is event.currentTarget.\n    // So, we must bind the controller object to 'this' to override\n    return this.#userEventHandlers[id].bind(this);\n  }\n\n  // Helper function to bind Controller user-event-handler to webpage\n  // DOM elementId.\n  bindUserEventHandlerToId(elementId, eventName = 'click', dom = document) {\n    const element = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.eid)(elementId, dom);\n    if (element) {\n      const handler = this.userEventHandler(elementId);\n      element.addEventListener(eventName, handler);\n      this.#boundUserEventElements.push({ element, eventName, handler });\n    }\n  }\n\n  // Helper function to bind Controller user-event-handlers to a collection\n  // of webpage DOM elementIds.\n  bindUserEventHandlersToIds(\n    // all controller user event handlers\n    elementIds = this.userEventHandlerIds,\n    eventName = 'click',\n    dom = document,\n  ) {\n    elementIds.forEach((id) => {\n      this.bindUserEventHandlerToId(id, eventName, dom);\n    });\n  }\n\n  // Helper function to bind Controller user-event-handler to webpage\n  // DOM element class. Using element class names rather than element Ids\n  // allows us to add controller user-event-handler to more than one\n  // DOM element\n  bindUserEventHandlerToClass(\n    elementClass,\n    eventName = 'click',\n    dom = document,\n  ) {\n    const elements = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.ecs)(elementClass, dom);\n    elements.forEach((element) => {\n      const handler = this.userEventHandler(elementClass);\n      element.addEventListener(eventName, handler);\n      this.#boundUserEventElements.push({ element, eventName, handler });\n    });\n  }\n\n  // Helper function to bind Controller user-event-handlers to a collection\n  // of webpage DOM elementIds.\n  bindUserEventHandlersToClass(\n    // all user event handlers\n    elementClasses = this.userEventHandlerIds,\n    eventName = 'click',\n    dom = document,\n  ) {\n    elementClasses.forEach((ec) =>\n      this.bindUserEventHandlerToClass(ec, eventName, dom),\n    );\n  }\n\n  ////////////////////////////////\n  //// Public property accessors\n  ////////////////////////////////\n\n  get isValid() {\n    return this.#isValidController;\n  }\n\n  // Accessors for public property currentCell\n  get currentCell() {\n    return this.#current.cell;\n  }\n  set currentCell(newCell) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`currentCell: ${newCell}`);\n    const oldCell = this.currentCell;\n    if (newCell !== oldCell) {\n      this.#current.cell = newCell;\n      this.inputElement(newCell).focus();\n      (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.styleCurrentCell)(this, newCell, oldCell);\n    }\n  }\n\n  // Accessors for public property currentClue\n  get currentClue() {\n    return this.#current.clue;\n  }\n  set currentClue(newClue) {\n    const oldClue = this.currentClue;\n    if (newClue !== oldClue) {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`currentClue: '${newClue}' [currentCell ${this.currentCell}]`);\n      this.#current.clue = newClue;\n      (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.styleCurrentClue)(this, newClue, oldClue);\n      // check if new current clue includes current cell\n      if (!this.currentClue.cells.includes(this.currentCell)) {\n        // switch to first cell of new current clue\n        this.currentCell = newClue.cells[0];\n      }\n      this.#stateChange('clueSelected', newClue);\n    }\n  }\n\n  // Accessor for public property model\n  get model() {\n    return this.#crosswordModel;\n  }\n\n  // Accessor for public property gridView\n  get gridView() {\n    return this.#gridView;\n  }\n\n  // Accessor for public property cluesView\n  get cluesView() {\n    return this.#cluesView;\n  }\n\n  // Accessor for addEventsListener - public event publisher\n  get addEventsListener() {\n    return this.#addEventsListener;\n  }\n\n  // Accessor for public property controllerEventNames\n  get controllerEventNames() {\n    // Return array copy\n    return [...this.#controllerEventNames];\n  }\n\n  // Accessors for public property lastMoveEvent\n  get lastMoveEvent() {\n    return this.#lastMoveEvent;\n  }\n  set lastMoveEvent(eventName) {\n    const en = eventName.toLowerCase();\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(['click', 'focus'].includes(en), `unknown event: ${eventName}`);\n    this.#lastMoveEvent = en;\n  }\n  // Accessor for public property userEventHandlerIds\n  get userEventHandlerIds() {\n    return Object.keys(this.#userEventHandlers);\n  }\n\n  //////////////////////////\n  //// Public methods\n  //////////////////////////\n\n  /**\n   * Programmatically set the content of a crossword grid cell\n   * @param {*} cellElementId The id of the associated cell DOM element\n   * @param {*} character The new text content for the cell.\n   */\n  setGridCell(cellElementId, character) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`setCell:${cellElementId} '${character}}'`);\n    const clearRevealed = true;\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.setCellText)(\n      this,\n      this.#cellMap.modelCell(cellElementId),\n      character,\n      clearRevealed,\n    );\n  }\n\n  loadCrosswordSource(mimeType, crosswordSourceText, sourceFileName = '') {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(mimeType, '[mimeType] is undefined or null');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(crosswordSourceText, '[crosswordSourceText] is undefined or null');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`loadCrosswordSource: ${mimeType} ${sourceFileName}`);\n    // Build a crossword definition\n    const definition = (0,_crossword_model_mjs__WEBPACK_IMPORTED_MODULE_4__.newCrosswordDefinition)(mimeType, crosswordSourceText);\n    if (!definition) {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(\n        `loadCrosswordSource: invalid crossword definition \"${sourceFileName}\"`,\n        'error',\n      );\n      return false;\n    }\n\n    return this.#bindDefinition(definition);\n  }\n\n  setKeyboardEventBindings(eventBindings) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n      eventBindings?.length,\n      '[eventBindings] argument is empty, null or undefined.',\n    );\n    const supportedEvents = ['keydown', 'keyup'];\n    eventBindings.forEach((eb) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n        eb.eventName?.trim(),\n        `Missing or empty \"eventName\" property for event binding.`,\n      );\n      const ebn = eb.eventName.trim().toLowerCase();\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n        supportedEvents.includes(ebn),\n        `Binding event name \"${eb.eventName}\" is not supported.`,\n      );\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n        eb.keyBindings?.length,\n        `Missing or  empty \"keyBindings\" array property for [${ebn}].`,\n      );\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`setKeyboardEventBindings: Setting keyBindings for \"${ebn}\".`);\n      this.#keyboardEventBindings[ebn] = eb.keyBindings;\n    });\n  }\n\n  /////////////////////////////////\n  //// Public user event handlers\n  /////////////////////////////////\n\n  testCurrentClue() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`testCurrentClue:${this.currentClue}`);\n    const showIncorrect = true;\n    const outcome = (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.testClue)(this, this.currentClue, showIncorrect);\n    this.#stateChange('clueTested', outcome);\n    if (outcome === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.correct) {\n      this.#delayPublish('clueSolved', this.currentClue);\n    } else if (outcome === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.incomplete) {\n      this.#delayPublish('clueIncomplete', this.currentClue);\n    }\n    return outcome;\n  }\n\n  testCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('testCrossword');\n    const showIncorrect = true;\n    // call the crossword-controller-helper testCrossword\n    const outcome = (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.testCrossword)(this, showIncorrect);\n    this.#stateChange('crosswordTested', outcome);\n    if (outcome === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.correct) {\n      this.#delayPublish('crosswordSolved', this.#crosswordModel);\n    } else if (outcome === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.incomplete) {\n      this.#delayPublish('crosswordIncomplete', this.#crosswordModel);\n    }\n    return outcome;\n  }\n\n  revealCurrentCell() {\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.revealCell)(this, this.currentCell);\n    this.#stateChange('cellRevealed', this.currentCell);\n    this.#checkSolved();\n  }\n\n  revealCurrentClue() {\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.revealClue)(this, this.currentClue);\n    this.#stateChange('clueRevealed', this.currentClue);\n    this.#checkSolved();\n  }\n\n  revealCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('revealCrossword');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.revealCrossword)(this);\n    this.#stateChange('crosswordRevealed', this.model);\n    //No crosswordSolved event is published in this case\n  }\n\n  resetCurrentClue() {\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.resetClue)(this, this.currentClue);\n    this.#stateChange('clueReset', this.currentClue);\n  }\n\n  resetCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('resetCrossword');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.resetCrossword)(this);\n    this.#stateChange('crosswordReset', this.model);\n  }\n\n  cleanCurrentClue() {\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.cleanClue)(this, this.currentClue);\n    this.#stateChange('clueCleaned', this.currentClue);\n  }\n\n  cleanCrossword() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('cleanCrossword');\n    (0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.cleanCrossword)(this);\n    this.#stateChange('crosswordCleaned', this.model);\n  }\n\n  //////////////////////////\n  //// Private methods\n  //////////////////////////\n\n  // Accessor for document associated with DOM\n  get #document() {\n    return this.#gridParent.ownerDocument;\n  }\n\n  // Accessors for DOM parent/placeholder elements\n\n  get #gridParent() {\n    return this.#domGridParentElement;\n  }\n\n  get #cluesParent() {\n    return this.#domCluesParentElement;\n  }\n  // Common logic for CrosswordController constructor and loadCrosswordSource()\n  #bindDefinition(crosswordDefinition) {\n    // Build a crossword model\n    const model = (0,_crossword_model_mjs__WEBPACK_IMPORTED_MODULE_4__.newCrosswordModel)(crosswordDefinition);\n    if (!model) {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('#bindDefinition: crosswordModel creation failed', 'error');\n      return false;\n    }\n\n    // Do we have an existing model?\n    if (this.model) {\n      // Detach DOM elements dependent on old crosswordModel\n      this.#gridParent.removeChild(this.gridView);\n      this.#cluesParent?.removeChild(this.cluesView);\n      // Clear all mappings for old model\n      this.#cellMap = new _cell_map_mjs__WEBPACK_IMPORTED_MODULE_0__.CellMap();\n    }\n    ////  Rebuild and rebind for new model\n\n    this.#crosswordModel = model;\n\n    // (Re)build gridView and fill cellMap\n    this.#gridView = (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.newCrosswordGridView)(\n      this.#document,\n      this.model,\n      this.#cellMap,\n    );\n\n    // For light cells, wire up controller event listeners\n    this.#cellMap.modelCells\n      .filter((cell) => cell.light)\n      .forEach((lc) => {\n        this.#addCellEventListeners(lc.cellElement);\n        this.#addInputEventListeners(this.inputElement(lc));\n      });\n\n    //  Add the crossword grid to the webpage DOM\n    this.#gridParent.appendChild(this.gridView);\n\n    // Build the DOM for the crossword clues.\n    if (this.#cluesParent) {\n      this.#cluesView = (0,_crossword_cluesview_mjs__WEBPACK_IMPORTED_MODULE_1__.newCrosswordCluesView)(this.#document, this);\n      //  Add the crossword clues to the webpage DOM\n      this.#cluesParent.appendChild(this.cluesView);\n    }\n\n    // Select the first \"across\" head clue segment when the grid is complete and visible.\n    this.currentClue = this.model.acrossClues.headSegments[0];\n\n    // We're done! Publish event and go.\n    this.#stateChange('crosswordLoaded', crosswordDefinition);\n    return true;\n  }\n\n  // Helper function for constructor\n  #mapDomIdentsToUserEventHandlers = () => {\n    // Mapping of DOM element idents (ids or classes) to event handler methods\n    this.#userEventHandlers = {\n      // Reveal solution for current letter in answer. All revealed cells have\n      // distinct styling which remains for the duration of the puzzle.\n      // Public shaming is strictly enforced!\n      'reveal-cell': this.revealCurrentCell,\n      // Remove incorrect letters in the answer after testing.\n      'clean-clue': this.cleanCurrentClue,\n      // Clear out the answer for the current clue\n      'reset-clue': this.resetCurrentClue,\n      // Reveal solution for current clue\n      'reveal-clue': this.revealCurrentClue,\n      // Test the current clue answer against the solution. Incorrect letters\n      // have distinct styling which is removed when 'cleared' or a new letter\n      // entered in the cell.\n      'test-clue': this.testCurrentClue,\n      // Clear out all incorrect letters in the entire crossword\n      'clean-crossword': this.cleanCrossword,\n      // Clear out the entire crossword\n      'reset-crossword': this.resetCrossword,\n      // Reveal solutions for the entire crossword.\n      'reveal-crossword': this.revealCrossword,\n      // Test the answers for the entire crossword against the solutions\n      'test-crossword': this.testCrossword,\n    };\n  };\n\n  // Helper function to subscribe to CrosswordController events.\n  // Refer to #controllerEventNames for complete list of events.\n  #addEventsListener = (eventNames, callback) => {\n    eventNames.forEach((en) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n        this.controllerEventNames.includes(en),\n        `event [${en}] is not a CrosswordController event.`,\n      );\n      this.#eventSubscribers.push(this.#pubSub.subscribe(en, callback));\n    });\n  };\n\n  // Helper for multi-segment current clue\n  #isSiblingClue = (clue) => {\n    return (\n      clue &&\n      (clue === this.currentClue.previousClueSegment ||\n        clue === this.currentClue.nextClueSegment)\n    );\n  };\n\n  #hasClueChanged = (focusCell) => {\n    // Helper\n    const resolution = (focusCell, newCurrentClue) => {\n      if (newCurrentClue !== this.currentClue) {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(\n          `Clue has changed [was ${this.currentClue}, ` +\n            `focused ${focusCell}] => ${newCurrentClue}`,\n        );\n        this.currentClue = newCurrentClue;\n      }\n    };\n\n    // assigned values below are clueModel references or undefined\n    const [previous, cellAcross, cellDown, ai, di] = [\n      this.currentClue,\n      focusCell.acrossClue,\n      focusCell.downClue,\n      focusCell.acrossClueLetterIndex,\n      focusCell.downClueLetterIndex,\n    ];\n    //  We are in the current clue\n    if ([cellAcross, cellDown].includes(this.currentClue)) {\n      resolution(focusCell, this.currentClue);\n    } else if (cellAcross ? !cellDown : cellDown) {\n      //  We have an across clue or a down clue, but not both (i.e. xor).\n      resolution(focusCell, cellAcross ?? cellDown);\n    } else if (this.#isSiblingClue(cellAcross)) {\n      //  We've got cellAcross. If we are moving between clue segments,\n      //  choose the next/previous segment\n      resolution(focusCell, cellAcross);\n    } else if (this.#isSiblingClue(cellDown)) {\n      //  We've got cellDown. If we are moving between clue segments,\n      //  choose the next/previous segment\n      resolution(focusCell, cellDown);\n    } else {\n      //  Prefer cellAcross, unless we're on the start of a down clue\n      //  and not the start of an across clue\n      resolution(focusCell, di === 0 && ai !== 0 ? cellDown : cellAcross);\n    }\n    return this.currentClue !== previous;\n  };\n\n  /**\n   * **#stateChange**: Publish an event to the listeners subscribed to _onStateChange_.\n   * @param {*} eventName The name of the event to be published\n   * @param {*} data not used\n   */\n  #stateChange(eventName, data) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`stateChange: ${eventName}`);\n    this.#pubSub.publish(eventName, data);\n  }\n\n  // Flush DOM event queue before publishing event\n  // Used to publish user notification events so pending events complete first.\n  #delayPublish(eventName, eventData) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(\n      this.controllerEventNames.includes(eventName),\n      `unknown event \"${eventName}\"`,\n    );\n    setTimeout(() => {\n      this.#stateChange(eventName, eventData);\n    }, publicationDelayMs);\n  }\n\n  // Helper to publish crosswordSolved event if the crossword is solved\n  #checkSolved() {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('checkSolved');\n    if ((0,_crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.checkSolved)(this) === _crossword_controller_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.Outcome.correct) {\n      this.#delayPublish('crosswordSolved', this.model);\n    }\n  }\n\n  // Assign event handlers to cell's input element\n  #addInputEventListeners(inputElement) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(inputElement, 'inputElement is null or undefined');\n    const controller = this;\n\n    // 1. A user clicking on or touching an unfocussed inputElement generates\n    //    two events (focus, click)\n    // 2. A user clicking on a focussed inputElement only produces a click event\n    // 3. Keyboard-based movements set currentCell programmatically,\n    //    and the setter method calls element.focus() only, AFTER setting\n    //    the currentCell value.\n\n    //  Listen for focus events.\n    inputElement.addEventListener('focus', (event) => {\n      //  Get the cell data.\n      const eventCell = controller.cell(event.target.parentNode);\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`event:focus ${eventCell}`);\n      // Have this event fired as a result of a touch or mouse click?\n      if (controller.currentCell !== eventCell) {\n        controller.currentCell = eventCell;\n      }\n      controller.lastMoveEvent = 'focus';\n      controller.#hasClueChanged(eventCell);\n    });\n\n    //  Listen for click events.\n    inputElement.addEventListener('click', (event) => {\n      const eventCell = controller.cell(event.target.parentNode);\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`event:click ${eventCell}`);\n      // Test for second click on same cell\n      if (eventCell === controller.currentCell) {\n        // We don't want this to toggle clue direction if\n        // immediately preceding event was a focus:\n        if (controller.lastMoveEvent === 'click') {\n          (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.toggleClueDirection)(controller, eventCell);\n        }\n      } else {\n        controller.currentCell = eventCell;\n      }\n      controller.lastMoveEvent = 'click';\n    });\n  }\n\n  // Assign event handlers to cell's input element\n  #addCellEventListeners(cellElement) {\n    const controller = this;\n\n    // Iterate over bindable keyboard events\n    Object.keys(controller.#keyboardEventBindings).forEach((eventName) => {\n      const keyBindings = controller.#keyboardEventBindings[eventName];\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.assert)(keyBindings, `\"${eventName}\" bindings are null or undefined.`);\n      cellElement.addEventListener(eventName, (event) => {\n        const eventKey = event.key;\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`event:${eventName} key=[${eventKey}]`);\n        const keyBinding = keyBindings.find((kb) => kb.key === eventKey);\n\n        if (keyBinding) {\n          //  We don't want default behaviour.\n          event.preventDefault();\n          const ekName = _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.EventKey.name(eventKey).toUpperCase();\n          (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(event.shiftKey ? `SHIFT+${ekName}` : ekName);\n          const eventCell = controller.cell(event.target.parentNode);\n          keyBinding.action(controller, event, eventCell);\n        }\n      });\n    });\n\n    //  Listen for keypress events.\n    cellElement.addEventListener('keypress', (event) => {\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('event:keypress');\n      // We've just pressed a key that generates a character.\n      // Stop default handling for input component\n      event.preventDefault();\n      //  Get cell data.\n      const [eventCell, character] = [\n        controller.cell(event.target.parentNode),\n        event.key,\n      ];\n      const [testCharacter, displayCharacter] = [\n        character.toLowerCase(),\n        character.toUpperCase(),\n      ];\n\n      if (echoingKeyPressCharacters.test(testCharacter)) {\n        //  Sets the letter in the current clue cell.\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)(`Setting cell content: [${displayCharacter}]`);\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.setCellContent)(controller, event, displayCharacter);\n        // remove any visual flag in cell that letter is incorrect\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.hideElement)(controller.incorrectElement(eventCell));\n        // test for crossword completion\n        controller.#checkSolved();\n      }\n\n      if (advancingKeyPressCharacters.test(testCharacter)) {\n        //  Move to the next cell in the clue.\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_6__.trace)('Advancing to next cell');\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_3__.moveToCellAhead)(controller, eventCell);\n      }\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-controller.mjs?");

/***/ }),

/***/ "./src/crossword-gridview.mjs":
/*!************************************!*\
  !*** ./src/crossword-gridview.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventKey\": () => (/* binding */ EventKey),\n/* harmony export */   \"deleteCellContent\": () => (/* binding */ deleteCellContent),\n/* harmony export */   \"hideElement\": () => (/* binding */ hideElement),\n/* harmony export */   \"moveToCellAhead\": () => (/* binding */ moveToCellAhead),\n/* harmony export */   \"moveToCellBehind\": () => (/* binding */ moveToCellBehind),\n/* harmony export */   \"moveToCellDown\": () => (/* binding */ moveToCellDown),\n/* harmony export */   \"moveToCellLeft\": () => (/* binding */ moveToCellLeft),\n/* harmony export */   \"moveToCellRight\": () => (/* binding */ moveToCellRight),\n/* harmony export */   \"moveToCellUp\": () => (/* binding */ moveToCellUp),\n/* harmony export */   \"moveToClueAhead\": () => (/* binding */ moveToClueAhead),\n/* harmony export */   \"moveToClueBehind\": () => (/* binding */ moveToClueBehind),\n/* harmony export */   \"newCrosswordGridView\": () => (/* binding */ newCrosswordGridView),\n/* harmony export */   \"setCellContent\": () => (/* binding */ setCellContent),\n/* harmony export */   \"showElement\": () => (/* binding */ showElement),\n/* harmony export */   \"styleCurrentCell\": () => (/* binding */ styleCurrentCell),\n/* harmony export */   \"styleCurrentClue\": () => (/* binding */ styleCurrentClue),\n/* harmony export */   \"toggleClueDirection\": () => (/* binding */ toggleClueDirection)\n/* harmony export */ });\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\n/**\n * Build a crossword grid DOM element\n * with separate blocks for across and down clues.\n * @param {*} document the root node of the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model#DOM_tree_structure)\n * @param {*} model the crossword model object\n * @returns the grid DOM element\n */\n\nfunction newCrosswordGridView(document, model, cellMap) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('newCrosswordGridView');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(\n    document,\n    'DOM root element [document] argument is null or undefined.',\n  );\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(model, 'CrosswordModel [model] argument is null or undefined.');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(\n    cellMap,\n    'CrosswordController [cellMap] argument is null or undefined.',\n  );\n\n  let gridView = document.createElement('div');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(gridView, 'crosswords-js');\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(gridView, 'crossword-grid');\n\n  // Set the grid size variables, refer to style/crosswords.less\n  // This lets us adjust the CSS grid size to match 'model' dimensions.\n  gridView.style.setProperty('--row-count', model.height);\n  gridView.style.setProperty('--column-count', model.width);\n\n  //  Create each cell.\n  for (let y = 0; y < model.height; y += 1) {\n    for (let x = 0; x < model.width; x += 1) {\n      const modelCell = model.cells[x][y];\n\n      //  Build the cell element.\n      const cellElement = newCellElement(document, modelCell);\n      //  Update the map of cells to enable element lookups\n      cellMap.add(modelCell, cellElement);\n      // Place cell in grid element\n      gridView.appendChild(cellElement);\n    }\n  }\n\n  return gridView;\n}\n\n/**\n * Build a crossword grid _cell_ DOM element with child elements.\n * @param {*} document the root node of the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model#DOM_tree_structure)\n * @param {*} modelCell the representation of this grid cell in the  _crosswordModel_.\n * @returns the DOM element for the _cell_\n */\nfunction newCellElement(document, modelCell) {\n  let cellElement = document.createElement('div');\n  // Identify cellElement with id of associated modelCell.\n  // This simplifies implementation of CellMap\n  cellElement.id = modelCell;\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(cellElement, 'cwcell');\n  //  eslint-disable-next-line no-param-reassign\n  modelCell.cellElement = cellElement;\n  //  Add a class.\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(cellElement, modelCell.light ? 'light' : 'dark');\n\n  //  If the cell is dark, we are done.\n  if (!modelCell.light) {\n    return cellElement;\n  }\n\n  //  Light cells also need an input.\n  const inputElement = document.createElement('input');\n  // 'id' is not used, but assignment silences chromium-dev-tools issue.\n  inputElement.id = `input-${modelCell}`;\n  inputElement.maxLength = 1;\n  inputElement.size = 1;\n  if (modelCell.answer) {\n    inputElement.value = modelCell.answer;\n  }\n  cellElement.appendChild(inputElement);\n\n  //  We may need to add a clue label.\n  if (modelCell.labelText) {\n    const labelText = document.createElement('div');\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(labelText, 'cwclue-label');\n    labelText.innerHTML = modelCell.labelText;\n    cellElement.appendChild(labelText);\n  }\n\n  const revealedIndicator = document.createElement('div');\n  // Remove 'hidden' div class to reveal\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClasses)(revealedIndicator, ['cwcell-revealed', 'hidden']);\n  cellElement.appendChild(revealedIndicator);\n\n  const incorrectIndicator = document.createElement('div');\n  // Toggle 'hidden' div class to reveal/hide\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClasses)(incorrectIndicator, ['cwcell-incorrect', 'hidden']);\n  cellElement.appendChild(incorrectIndicator);\n\n  //  Check for clue answer segment terminators (across and/or down)\n  if (modelCell.acrossTerminator) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(inputElement, 'cw-across-word-separator');\n  }\n  if (modelCell.downTerminator) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(inputElement, 'cw-down-word-separator');\n  }\n\n  return cellElement;\n}\n\nfunction toggleClueDirection(crosswordController, eventCell) {\n  //  If we are in a eventCell with an across clue AND down clue, swap the\n  //  current clue.\n  const [ec, cc, swappable] = [\n    eventCell,\n    crosswordController,\n    eventCell.acrossClue && eventCell.downClue,\n  ];\n\n  if (swappable) {\n    // swap clue direction\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.trace)('toggleClueDirection');\n    // eslint-disable-next-line no-param-reassign\n    cc.currentClue =\n      ec.acrossClue === cc.currentClue ? ec.downClue : ec.acrossClue;\n  }\n\n  return swappable;\n}\n\nfunction moveToSegmentAhead(crosswordController, eventCell) {\n  const [ec, , clue] = [\n    eventCell,\n    crosswordController,\n    crosswordController.currentClue,\n  ];\n  const currentIndex =\n    ec.acrossClue === clue ? ec.acrossClueLetterIndex : ec.downClueLetterIndex;\n  const nextIndex = currentIndex + 1;\n  //  If we are at the end of the clue and we have a next segment, select it.\n  const jumpable = nextIndex === clue.cells.length && clue.nextClueSegment;\n\n  if (jumpable) {\n    // eslint-disable-next-line no-param-reassign\n    cc.currentClue = clue.nextClueSegment;\n  }\n\n  return jumpable;\n}\n\nfunction moveToSegmentBehind(crosswordController, eventCell) {\n  const [ec, cc] = [eventCell, crosswordController];\n  const clue = cc.currentClue;\n  const currentIndex =\n    ec.acrossClue === clue ? ec.acrossClueLetterIndex : ec.downClueLetterIndex;\n  const previousIndex = currentIndex - 1;\n  //  If we are at the start of the clue and we have a previous segment, select it.\n  const jumpable = previousIndex === -1 && clue.previousClueSegment;\n\n  if (jumpable) {\n    // eslint-disable-next-line no-param-reassign\n    cc.currentCell = clue.previousClueSegment.cells.slice(-1)[0];\n    // eslint-disable-next-line no-param-reassign\n    cc.currentClue = clue.previousClueSegment;\n  }\n\n  return jumpable;\n}\n\nfunction moveToCellDown(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n  const { height } = eventCell.model;\n  let moved = false;\n\n  if (\n    eventCell.y + 1 < height &&\n    eventCell.model.cells[x][y + 1].light === true\n  ) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x][y + 1];\n    moved = true;\n  } else {\n    // Can we go to next segment in clue?\n    moved = moveToSegmentAhead(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction moveToCellRight(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n  const { width } = eventCell.model;\n  let moved = false;\n\n  if (\n    eventCell.x + 1 < width &&\n    eventCell.model.cells[x + 1][y].light === true\n  ) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x + 1][y];\n    moved = true;\n  } else {\n    // Can we go to next segment in clue?\n    moved = moveToSegmentAhead(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction moveToCellUp(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n  let moved = false;\n\n  if (eventCell.y > 0 && eventCell.model.cells[x][y - 1].light === true) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x][y - 1];\n    moved = true;\n  } else {\n    // Can we go to previous segment in clue?\n    moved = moveToSegmentBehind(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction moveToCellLeft(crosswordController, eventCell) {\n  const { x, y } = eventCell;\n  let moved = false;\n\n  if (eventCell.x > 0 && eventCell.model.cells[x - 1][y].light === true) {\n    // eslint-disable-next-line no-param-reassign\n    crosswordController.currentCell = eventCell.model.cells[x - 1][y];\n    moved = true;\n  } else {\n    // Can we go to previous segment in clue?\n    moved = moveToSegmentBehind(crosswordController, eventCell);\n  }\n\n  return moved;\n}\n\nfunction moveToCellAhead(crosswordController, eventCell) {\n  // move to previous cell in current clue\n  if (crosswordController.currentClue === eventCell.acrossClue) {\n    return moveToCellRight(crosswordController, eventCell);\n  } else if (crosswordController.currentClue === eventCell.downClue) {\n    return moveToCellDown(crosswordController, eventCell);\n  }\n}\n\nfunction moveToCellBehind(crosswordController, eventCell) {\n  // move to previous cell in current clue\n  if (crosswordController.currentClue === eventCell.acrossClue) {\n    return moveToCellLeft(crosswordController, eventCell);\n  } else if (crosswordController.currentClue === eventCell.downClue) {\n    return moveToCellUp(crosswordController, eventCell);\n  }\n}\n\nconst getHeadClues = (crosswordModel, clue) => {\n  return clue.isAcross\n    ? [\n        crosswordModel.acrossClues.headSegments,\n        crosswordModel.downClues.headSegments,\n      ]\n    : [\n        crosswordModel.downClues.headSegments,\n        crosswordModel.acrossClues.headSegments,\n      ];\n};\n\nfunction moveToClueAhead(controller, eventCell) {\n  const clue = controller.currentClue.headSegment;\n  const [headClues, orthogonalHeadClues] = getHeadClues(eventCell.model, clue);\n  const hci = headClues.indexOf(clue);\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(hci !== -1, `clue '${clue.clueId}' not found in headClues`);\n\n  // eslint-disable-next-line no-param-reassign\n  controller.currentClue =\n    hci === headClues.length - 1\n      ? // current head is last - flip direction, get first head clue\n        orthogonalHeadClues[0]\n      : // get next head\n        headClues[hci + 1];\n}\n\nfunction moveToClueBehind(controller, eventCell) {\n  const clue = controller.currentClue.headSegment;\n  const [headClues, orthogonalHeadClues] = getHeadClues(eventCell.model, clue);\n  const hci = headClues.indexOf(clue);\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(hci !== -1, `clue '${clue.clueId}' not found in headClues`);\n\n  // eslint-disable-next-line no-param-reassign\n  controller.currentClue =\n    hci === 0\n      ? // current head is first - flip direction, get last head clue\n        orthogonalHeadClues.slice(-1)[0]\n      : // get previous head\n        headClues[hci - 1];\n}\n\nfunction deleteCellContent(crosswordController, event, eventCell) {\n  // Fill cell with SPACE\n  setCellContent(crosswordController, event, ' ');\n  // remove any visual flag in cell that letter is incorrect\n  hideElement(crosswordController.incorrectElement(eventCell));\n}\n\nfunction setCellContent(crosswordController, event, character) {\n  const ec = crosswordController.cell(event.target.parentNode);\n\n  //  eslint-disable-next-line no-param-reassign\n  event.target.value = character;\n\n  //  We need to update the answers\n  if (ec.acrossClue) {\n    ec.acrossClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(\n      ec.acrossClue.answer,\n      ec.acrossClueLetterIndex,\n      character,\n    );\n  }\n  // across and/or down are possible\n  if (ec.downClue) {\n    ec.downClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setLetter)(\n      ec.downClue.answer,\n      ec.downClueLetterIndex,\n      character,\n    );\n  }\n}\n\nconst hideElement = (element) => {\n  element?.classList.add('hidden');\n};\n\nconst showElement = (element) => {\n  element?.classList.remove('hidden');\n};\n\n//  Style the currentClue.\nfunction styleCurrentClue(controller, newClue, oldClue) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(newClue, 'newClue is undefined');\n  // Remove styles from the oldClue\n  oldClue?.headSegment.flatCells.forEach((cell) => {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.removeClass)(controller.inputElement(cell), 'active');\n  });\n  newClue.headSegment.flatCells.forEach((cell) => {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(controller.inputElement(cell), 'active');\n  });\n}\n\n//  Style the currentCell.\nfunction styleCurrentCell(controller, newCell, oldCell) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(newCell, 'newCell is undefined');\n  // Remove styles from the oldCell\n  if (oldCell) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.removeClass)(controller.inputElement(oldCell), 'highlighted');\n  }\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addClass)(controller.inputElement(newCell), 'highlighted');\n}\n\nconst EventKey = Object.freeze({\n  backspace: 'Backspace',\n  delete: 'Delete',\n  down: 'ArrowDown',\n  enter: 'Enter',\n  left: 'ArrowLeft',\n  right: 'ArrowRight',\n  space: ' ',\n  tab: 'Tab',\n  up: 'ArrowUp',\n  shift: 'Shift',\n  alt: 'Alt',\n  ctrl: 'Control',\n  name: (eventKey) => {\n    // entry is an array [key, value]\n    const entry = Object.entries(EventKey).find(\n      (entry) => entry[1] === eventKey,\n    );\n    return entry ? entry[0] : null;\n  },\n});\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-gridview.mjs?");

/***/ }),

/***/ "./src/crossword-model.mjs":
/*!*********************************!*\
  !*** ./src/crossword-model.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertSourceFileToDefinition\": () => (/* binding */ convertSourceFileToDefinition),\n/* harmony export */   \"isWordSeparatorIndex\": () => (/* binding */ isWordSeparatorIndex),\n/* harmony export */   \"newCrosswordDefinition\": () => (/* binding */ newCrosswordDefinition),\n/* harmony export */   \"newCrosswordModel\": () => (/* binding */ newCrosswordModel)\n/* harmony export */ });\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'yaml'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _clue_model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clue-model.mjs */ \"./src/clue-model.mjs\");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.mjs */ \"./src/helpers.mjs\");\n\n\n\n\n/**\n * **newCrosswordModel**: build a crossword model from a crosswordDefinition object.\n * - The function compiles a JSON crossword and emits diagnostic exceptions when errors are encountered.\n * @param {*} crosswordDefinition A javascript Object typically parsed or imported from a crossword description file in JSON or YAML format.\n * @returns a crossword model object\n */\nfunction newCrosswordModel(crosswordDefinition) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trace)('newCrosswordModel');\n\n  if (!validateCrosswordDefinition(crosswordDefinition)) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trace)(\n      'newCrosswordModel: The model must be initialised with a valid crossword definition.',\n      `error`,\n    );\n    return null;\n  }\n\n  //  Create the basic crosswordModel structure.\n  let crosswordModel = initialiseCrosswordModel(crosswordDefinition);\n  //  Create the array of cells. Each element has a reference back to the crosswordModel\n  //  for convenience.\n  crosswordModel.cells = buildCellGrid(crosswordModel);\n\n  //  Add all the crosswordDefinition clues to the crosswordModel.\n  const isAcross = /across/i;\n  ['acrossClues', 'downClues'].forEach((clues) => {\n    crosswordDefinition[clues].forEach(\n      addClueToModel(crosswordModel, isAcross.test(clues)),\n    );\n  });\n\n  //  Process any multi-segment clues.\n  [...crosswordModel.acrossClues, ...crosswordModel.downClues].forEach(\n    addMultiSegmentProperties(crosswordModel),\n  );\n\n  // Assign lightCells property\n  crosswordModel.lightCells = crosswordModel.cells\n    .flat()\n    .filter((cell) => cell.light);\n\n  // Assign headSegment (array) properties to model's acrossClues and downClues arrays.\n  ['acrossClues', 'downClues'].forEach((clues) => {\n    crosswordModel[clues].headSegments = crosswordModel[clues].filter(\n      (c) => c === c.headSegment,\n    );\n  });\n\n  return crosswordModel;\n}\n\n// Helper for newCrosswordModel()\nfunction buildCellGrid(crosswordModel) {\n  const { width } = crosswordModel;\n  const { height } = crosswordModel;\n  const array = new Array(width);\n  for (let x = 0; x < width; x += 1) {\n    array[x] = new Array(height);\n    for (let y = 0; y < height; y += 1) {\n      // assign cell object\n      array[x][y] = {\n        model: crosswordModel,\n        x,\n        y,\n        toString: () => {\n          return `(${x},${y})`;\n        },\n      };\n    }\n  }\n  return array;\n}\n\n// Helper for newCrosswordModel()\n/**\n * Is the character at letterIndex the last letter of a non-terminal\n * word in a multi-word sequence?\n * @param {*} letterIndex\n * @param {*} wordLengths array of word lengths\n * @returns boolean\n */\nfunction isWordSeparatorIndex(letterIndex, wordLengths) {\n  if (letterIndex >= 0) {\n    let remainingIndex = letterIndex;\n    let index = 0;\n    while (index < wordLengths.length) {\n      const wl = wordLengths[index];\n      if (remainingIndex < wl) {\n        return (\n          // is a word terminator\n          remainingIndex === wl - 1 &&\n          //  is not last word\n          index !== wordLengths.length - 1\n        );\n      } else {\n        remainingIndex -= wl;\n        index += 1;\n      }\n    }\n  }\n  return false;\n}\n\n// Helper for newCrosswordModel()\nfunction initialiseCrosswordModel(crosswordDefinition) {\n  let crosswordModel = {\n    width: crosswordDefinition.width,\n    height: crosswordDefinition.height,\n    acrossClues: [],\n    downClues: [],\n    cells: [],\n  };\n  if (\n    crosswordModel.width === undefined ||\n    crosswordModel.width === null ||\n    crosswordModel.width < 0 ||\n    crosswordModel.height === undefined ||\n    crosswordModel.height === null ||\n    crosswordModel.height < 0\n  ) {\n    throw new Error('The crossword bounds are invalid.');\n  }\n  return crosswordModel;\n}\n\n// Helper for newCrosswordModel()\nfunction validateCrosswordDefinition(crosswordDefinition) {\n  const versionRegex = /^1\\.0$/;\n\n  function error(message) {\n    (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trace)(`validateCrosswordDefinition: ${message}`, 'error');\n    return false;\n  }\n  function normalise(text) {\n    return text.toString().trim().toLowerCase();\n  }\n\n  const cd = crosswordDefinition;\n\n  // Test supplied arguments\n\n  if (!cd) {\n    return error('[crosswordDefinition] argument is undefined or null');\n  }\n\n  // Test for document element\n  else if (!cd.document) {\n    return error('Missing \"document\" element');\n  }\n  // Test for document.mimetype element\n  else if (!cd.document?.mimetype) {\n    return error('Missing \"document.mimetype\" element');\n  } else {\n    const mimeType = normalise(cd.document.mimetype);\n\n    // Test for valid mimetype\n\n    if (mimeType !== 'application/vnd.js-crossword') {\n      return error(\n        `Unsupported \"document.mimetype\" (${mimeType}) Expected: application/vnd.js-crossword`,\n      );\n    }\n    // Test for document.version element\n    else if (!cd.document?.version) {\n      return error('Missing \"document.mimetype\" element');\n    }\n\n    // Test for supported version\n    else {\n      const version = normalise(cd.document.version);\n\n      // Final test!\n      return versionRegex.test(version)\n        ? true\n        : error(`Unsupported document version (${version}) Expected: 1.0`);\n    }\n  }\n}\n\n// Helper for newCrosswordModel()\nfunction validateClueInCrossword(clueModel, crosswordModel, isAcrossClue) {\n  if (\n    clueModel.x < 0 ||\n    clueModel.x >= crosswordModel.width ||\n    clueModel.y < 0 ||\n    clueModel.y >= crosswordModel.height\n  ) {\n    throw new Error(`Clue ${clueModel} doesn't start in the bounds.`);\n  }\n\n  //  Make sure the clue is not too long.\n  if (isAcrossClue) {\n    if (clueModel.x + clueModel.segmentLength > crosswordModel.width) {\n      throw new Error(`Clue ${clueModel} exceeds horizontal bounds.`);\n    }\n    // down clue\n  } else if (clueModel.y + clueModel.segmentLength > crosswordModel.height) {\n    throw new Error(`Clue ${clueModel} exceeds vertical bounds.`);\n  }\n}\n\n// Helper for newCrosswordModel()\nfunction updateOrthogonalClueAnswer(cell, answer, isAcrossClue) {\n  //  eslint-disable-next-line no-param-reassign\n\n  //  We need to update the answers\n  if (!isAcrossClue && cell.acrossClue) {\n    //  eslint-disable-next-line no-param-reassign\n    cell.acrossClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.setLetter)(\n      cell.acrossClue.answer,\n      cell.acrossClueLetterIndex,\n      answer,\n    );\n  }\n  if (isAcrossClue && cell.downClue) {\n    //  eslint-disable-next-line no-param-reassign\n    cell.downClue.answer = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.setLetter)(\n      cell.downClue.answer,\n      cell.downClueLetterIndex,\n      answer,\n    );\n  }\n}\n\n// Curried function returns a function to map a tailSegmentDescriptor to its clueModel (clue)\nconst tailDescriptorConverter = (crosswordModel) => {\n  return (tailDescriptor) => {\n    const cm = crosswordModel;\n    const td = tailDescriptor;\n    const hn = td.headNumber;\n\n    switch (td.direction) {\n      case 'across':\n        // non-terminal\n        return cm.acrossClues.find((ac) => ac.headNumber === hn);\n      case 'down':\n        // non-terminal\n        return cm.downClues.find((dc) => dc.headNumber === hn);\n      default:\n        // terminal (direction === null)\n        return (\n          cm.acrossClues.find((ac) => ac.headNumber === hn) ||\n          cm.downClues.find((dc) => dc.headNumber === hn)\n        );\n    }\n  };\n};\n\n// Curried function returns a function to add a crosswordDefinition clue to a crosswordModel\nfunction addClueToModel(crosswordModel, isAcrossClue) {\n  return (cdClue) => {\n    //  Compile the clue model from the crossword definition of the clue\n    const clueModel = (0,_clue_model_mjs__WEBPACK_IMPORTED_MODULE_1__.newClueModel)(cdClue, isAcrossClue);\n    //  Add clue model to crosswordModel clues array.\n    crosswordModel[isAcrossClue ? 'acrossClues' : 'downClues'].push(clueModel);\n\n    //  The clue position must be in the bounds.\n    validateClueInCrossword(clueModel, crosswordModel, isAcrossClue);\n\n    //  We can now mark the cells as light. If the clue has\n    //  an answer (which is optional), we can validate it\n    //  is coherent.\n    let { x, y } = clueModel;\n    for (\n      let letterIndex = 0;\n      letterIndex < clueModel.segmentLength;\n      letterIndex += 1\n    ) {\n      const cell = crosswordModel.cells[x][y];\n      cell.light = true;\n      cell[isAcrossClue ? 'acrossClue' : 'downClue'] = clueModel;\n      cell[isAcrossClue ? 'acrossClueLetterIndex' : 'downClueLetterIndex'] =\n        letterIndex;\n      clueModel.cells.push(cell);\n\n      //  Check if we need to add a word separator to the grid cell.\n      if (isWordSeparatorIndex(letterIndex, clueModel.wordLengths)) {\n        cell[clueModel.isAcross ? 'acrossTerminator' : 'downTerminator'] = true;\n      }\n\n      //  If the imported clue has an answer we set it in the cell...\n      setCellAnswer(cell, clueModel, letterIndex, cdClue.answer, isAcrossClue);\n      //  If the imported clue has a solution we set it in the cell...\n      setCellSolution(cell, clueModel, letterIndex, cdClue.solution);\n      //  //  Set label for first cell, and check against existing value\n      setCellLabel(letterIndex, cell, clueModel);\n\n      if (isAcrossClue) {\n        x += 1;\n      } else {\n        y += 1;\n      }\n    }\n  };\n}\n\nfunction setCellLabel(letterIndex, cell, clueModel) {\n  if (letterIndex === 0) {\n    if (cell.labelText && cell.labelText !== clueModel.headNumber) {\n      throw new Error(\n        `Clue ${clueModel} has a label which is inconsistent with another clue (${cell.acrossClue}).`,\n      );\n    }\n    // eslint-disable-next-line no-param-reassign\n    cell.labelText = clueModel.headNumber;\n  }\n}\n\n// Curried function returns a function to add multi-segment properties to a clueModel\nfunction addMultiSegmentProperties(crosswordModel) {\n  return (cmClue) => {\n    //  Find the connected clues. Pass curried iterator function\n    //  eslint-disable-next-line no-param-reassign\n    cmClue.tailSegments = cmClue.tailDescriptors.map(\n      tailDescriptorConverter(crosswordModel),\n    );\n\n    //  Rebuild the lengthText.\n    //  For head clue segments, it will be the aggregate of the multi-word descriptors for each segment.\n    //  For tail clue segments, it will be the multi-word descriptors for itself (no change).\n    const multiSegmentLengths = [\n      ...cmClue.wordLengths,\n      ...cmClue.tailSegments.flatMap((ts) => ts.wordLengths),\n    ];\n    //  eslint-disable-next-line no-param-reassign\n    cmClue.lengthText = `(${multiSegmentLengths})`;\n\n    //  Each clue should know its head segment as well as the next and\n    //  previous clue segments.\n    let clueSegmentIndex = 0;\n    const clueSegments = [cmClue, ...cmClue.tailSegments];\n\n    clueSegments.forEach((cs) => {\n      //  Set the head segment for _each_ clue segment via destructuring.\n      //  Note that the head segment for a one-segment clue is itself.\n      //  eslint-disable-next-line no-param-reassign\n      [cs.headSegment] = clueSegments;\n\n      // Assign previousClueSegment (all except first)\n      if (clueSegmentIndex > 0) {\n        //  eslint-disable-next-line no-param-reassign\n        cs.previousClueSegment = clueSegments[clueSegmentIndex - 1];\n      }\n\n      // Assign nextClueSegment (all except last)\n      if (clueSegmentIndex < clueSegments.length - 1) {\n        //  eslint-disable-next-line no-param-reassign\n        cs.nextClueSegment = clueSegments[clueSegmentIndex + 1];\n      }\n      clueSegmentIndex += 1;\n    });\n\n    // Assign flatCells property to head segment\n    clueSegments[0].flatCells =\n      clueSegments.length === 1\n        ? clueSegments[0].cells\n        : // Remove duplicates from intersecting multiple segments by constructing a set\n          new Set(clueSegments.flatMap((cs) => cs.cells));\n\n    //  Rewrite the clue label.\n    //  Head clues will get a comma-separated list of connected segments.\n    //  eslint-disable-next-line no-param-reassign\n    cmClue.labelText = `${[cmClue.headNumber]\n      .concat(cmClue.tailSegments.map((ts) => ts.headNumber))\n      .join(',')}.`;\n\n    //  The tail clues have no lengthText\n    cmClue.tailSegments.forEach((ts) => {\n      //  eslint-disable-next-line no-param-reassign\n      ts.lengthText = '';\n    });\n  };\n}\n\n/**\n * **convertSourceFileToDefinition** build a _crosswordDefinition_ from a YAML or JSON file.\n * @param {*} mimeType The [MIME](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) type of the\n * _documentText_: `application/json` or `application/yaml`\n * @param {*} crosswordSourcePath system file path to a JSON or YAML crosswordSource.\n * @returns {*} a crosswordDefinition Object on successful conversion, or null.\n *\n * > NOTE: This function can't be called from client/browser code.\n * > Local file system access is typically not allowed in that context.\n */\nfunction convertSourceFileToDefinition(mimeType, crosswordSourcePath) {\n  (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.assert)(fileExists(crosswordSourcePath));\n  const crosswordSource = readFileSync(crosswordSourcePath, {\n    encoding: 'utf8',\n    flag: 'r',\n  });\n\n  return newCrosswordDefinition(mimeType, crosswordSource.toString());\n}\n\n// Helper function to build a CrosswordDefinition\n\n/**\n * **newCrosswordDefinition** build a _crosswordDefinition_ from a _crosswordSource_ in JSON or YAML format.\n * @param {*} mimeType The [MIME](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) type of the\n * _documentText_, `application/json` or `application/yaml`\n * @param {*} crosswordSource a structured text description of a crossword puzzle in _mimeType_ format.\n * @returns {*} a crosswordDefinition object on successful conversion, or null.\n */\nfunction newCrosswordDefinition(mimeType, crosswordSource) {\n  let parsedDocument;\n  switch (mimeType.trim().toLowerCase()) {\n    case 'application/json':\n      try {\n        parsedDocument = JSON.parse(crosswordSource);\n      } catch (error) {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trace)(\n          `newCrosswordDefinition: [documentText] is not a simple JSON object.\\n` +\n            `Error: ${error.message}\\n`,\n          `error`,\n        );\n        return null;\n      }\n      break;\n    case 'application/yaml':\n    case 'application/x-yaml':\n      try {\n        parsedDocument = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'yaml'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(crosswordSource);\n      } catch (error) {\n        (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trace)(\n          `newCrosswordDefinition: [documentText] is not a YAML object.\\n` +\n            `Error: ${error.message}\\n`,\n          `error`,\n        );\n        return null;\n      }\n      break;\n    default:\n      (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.trace)(\n        `newCrosswordDefinition: Unsupported file type: (${mimeType})`,\n        'error',\n      );\n      return null;\n  }\n  return validateCrosswordDefinition(parsedDocument) ? parsedDocument : null;\n}\n\nfunction propertyErrorText(clueModel, cell, letterIndex, property) {\n  const gridCoords = `(${clueModel.x + 1},${clueModel.y + 1})`;\n  const propVal = `[${clueModel[property]}[${letterIndex + 1}],${\n    clueModel[property][letterIndex]\n  }]`;\n  const prevClue = `(${cell.acrossClue})`;\n  const prevVal = `[${cell.acrossClue[property]},${cell[property]}]`;\n\n  return (\n    `Clue ${clueModel} ${property} at ${gridCoords} ${propVal} is not coherent` +\n    ` with previous clue ${prevClue} ${property} ${prevVal}.`\n  );\n}\n\n// Helper function to set solution letter in a cell\nfunction setCellSolution(cell, clueModel, letterIndex, clueSolution) {\n  const cellDefaultSolution = ' ';\n\n  if (clueSolution) {\n    //  ...set solution only if it is NOT different to an existing solution.\n    if (\n      cell.solution &&\n      // We can overwrite any cells that have the default value\n      cell.solution !== cellDefaultSolution &&\n      cell.solution !== clueModel.solution[letterIndex]\n    ) {\n      throw new Error(\n        propertyErrorText(clueModel, cell, letterIndex, 'solution'),\n      );\n    } else {\n      // if (cell.solution && cell.solution !== ' '\n      // eslint-disable-next-line no-param-reassign\n      cell.solution = clueModel.solution[letterIndex];\n    }\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    cell.solution = cellDefaultSolution;\n  }\n}\n\n// Helper function to set answer letter in a cell\nfunction setCellAnswer(cell, clueModel, letterIndex, clueAnswer, isAcrossClue) {\n  const cellDefaultAnswer = ' ';\n\n  if (clueAnswer) {\n    const clueAnswerLetter = clueModel.answer[letterIndex];\n\n    //  ...but only if it is not different to an existing answer.\n    if (\n      cell.answer &&\n      // We can overwrite any cells that have default value\n      cell.answer !== cellDefaultAnswer &&\n      cell.answer !== clueAnswerLetter\n    ) {\n      throw new Error(\n        propertyErrorText(clueModel, cell, letterIndex, 'answer'),\n      );\n    }\n    // if cell.answer && cell.answer !== ' '\n    // eslint-disable-next-line no-param-reassign\n    cell.answer = clueAnswerLetter;\n    // check if cell appears in a clue in the other direction\n    updateOrthogonalClueAnswer(cell, cell.answer, isAcrossClue);\n  }\n\n  // No answer in imported clue, insert default if cell is vacant.\n  // Don't clobber an existing value\n  else if (!cell.answer) {\n    // eslint-disable-next-line no-param-reassign\n    cell.answer = cellDefaultAnswer;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/crossword-model.mjs?");

/***/ }),

/***/ "./src/default-eventbindings.mjs":
/*!***************************************!*\
  !*** ./src/default-eventbindings.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultKeyDownBinding\": () => (/* binding */ defaultKeyDownBinding),\n/* harmony export */   \"defaultKeyUpBinding\": () => (/* binding */ defaultKeyUpBinding)\n/* harmony export */ });\n/* harmony import */ var _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crossword-gridview.mjs */ \"./src/crossword-gridview.mjs\");\n\n\n// eventBinding = {eventName,keyBindings[keybinding,...]}\n// keybinding =  {key, action}\n// action = (controller, event, eventCell) => {...}\n\nconst defaultKeyDownBinding = {\n  eventName: 'keydown',\n  keyBindings: [\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.backspace,\n      action: (controller, event, eventCell) => {\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.deleteCellContent)(controller, event, eventCell);\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToCellBehind)(controller, eventCell);\n      },\n    },\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey[\"delete\"],\n      action: (controller, event, eventCell) => {\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.deleteCellContent)(controller, event, eventCell);\n      },\n    },\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.enter,\n      action: (controller, event, eventCell) => {\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.toggleClueDirection)(controller, eventCell);\n      },\n    },\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.tab,\n      action: (controller, event, eventCell) => {\n        event.shiftKey\n          ? (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToClueBehind)(controller, eventCell)\n          : (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToClueAhead)(controller, eventCell);\n      },\n    },\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.space,\n      action: (controller, event, eventCell) => {\n        event.shiftKey\n          ? (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToCellBehind)(controller, eventCell)\n          : (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToCellAhead)(controller, eventCell);\n      },\n    },\n  ],\n};\n\nconst defaultKeyUpBinding = {\n  eventName: 'keyup',\n  keyBindings: [\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.left,\n      action: (controller, event, eventCell) => {\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToCellLeft)(controller, eventCell);\n      },\n    },\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.up,\n      action: (controller, event, eventCell) => {\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToCellUp)(controller, eventCell);\n      },\n    },\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.right,\n      action: (controller, event, eventCell) => {\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToCellRight)(controller, eventCell);\n      },\n    },\n    {\n      key: _crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.EventKey.down,\n      action: (controller, event, eventCell) => {\n        (0,_crossword_gridview_mjs__WEBPACK_IMPORTED_MODULE_0__.moveToCellDown)(controller, eventCell);\n      },\n    },\n  ],\n};\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/default-eventbindings.mjs?");

/***/ }),

/***/ "./src/helpers.mjs":
/*!*************************!*\
  !*** ./src/helpers.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addClass\": () => (/* binding */ addClass),\n/* harmony export */   \"addClasses\": () => (/* binding */ addClasses),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"ecs\": () => (/* binding */ ecs),\n/* harmony export */   \"eid\": () => (/* binding */ eid),\n/* harmony export */   \"first\": () => (/* binding */ first),\n/* harmony export */   \"last\": () => (/* binding */ last),\n/* harmony export */   \"memoize\": () => (/* binding */ memoize),\n/* harmony export */   \"newPubSub\": () => (/* binding */ newPubSub),\n/* harmony export */   \"removeClass\": () => (/* binding */ removeClass),\n/* harmony export */   \"replaceStrAt\": () => (/* binding */ replaceStrAt),\n/* harmony export */   \"setLetter\": () => (/* binding */ setLetter),\n/* harmony export */   \"toHexString\": () => (/* binding */ toHexString),\n/* harmony export */   \"toggleClass\": () => (/* binding */ toggleClass),\n/* harmony export */   \"trace\": () => (/* binding */ trace),\n/* harmony export */   \"tracing\": () => (/* binding */ tracing)\n/* harmony export */ });\n// Lightweight helper functions.\n\n/**\n * **addClass** - add a [CSS](https://en.wikipedia.org/wiki/CSS) class to a\n * [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) element.\n * @param {*} element the element (object reference)\n * @param {*} className the class to add (string)\n */\nfunction addClass(element, className) {\n  element.classList.add(className);\n}\nfunction addClasses(element, classNames) {\n  classNames.forEach((cn) => {\n    element.classList.add(cn);\n  });\n}\n\n/**\n * **assert** - logical constraint testing\n * @param condition - test expression (boolean)\n * @param message - (string) recorded on test failure - _condition_ evaluates to `false`.\n */\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\n//// Shortcut functions\n\nconst eid = (elementId, dom = document) => {\n  return dom.getElementById(elementId);\n};\n\n// Returns an array of elements\nconst ecs = (elementClass, dom = document) => {\n  return dom.getElementsByClassName(elementClass);\n};\n\n/**\n * **first** - get the first element of an array\n * @param {*} array\n * @returns the first element of _array_ or null for empty,undefined or null array\n */\nfunction first(array) {\n  // If array is not nullish, return first element\n  return array ? array[0] : null;\n}\n\n/**\n * replaceStrAt - overlay **str** onto **original** string starting at **index**\n * @param original - the string to be mutated\n * @param index - the index of _original_ to start the overlay. Negative values supported like `string.slice()`.\n * @param str - the overlaying text\n * @returns the mutated _original_. Any null or undefined arguments returns _original_.\n * _index_ outside range [0,_original_.length) returns _original_.\n */\nfunction replaceStrAt(original, index, str) {\n  let result = original;\n  if (original && index != null && str) {\n    let pos = parseInt(index, 10);\n    if (pos < 0) {\n      // Normalise negative index values\n      pos = original.length + pos;\n    }\n    if (pos >= 0 && original.length > pos) {\n      result = `${original.slice(0, pos)}${str}${original.slice(\n        pos + str.length,\n      )}`;\n    }\n  }\n  return result;\n}\n\n/**\n * **last** - get the last element of an array\n * @param {*} array\n * @returns the last element of _array_ or null for empty,undefined or null array\n */\nfunction last(array) {\n  // If array is not nullish, return last element\n  return array ? array.slice(-1) : null;\n}\n\n/**\n * **memoize** - wrap an arbitrary, single-argument,\n * [idempotent](https://en.wikipedia.org/wiki/Idempotence)\n * function with result-caching.\n * Useful for [_expensive_](https://en.wikipedia.org/wiki/Analysis_of_algorithms) functions.\n * @param {*} fn the function to be [memoized](https://en.wikipedia.org/wiki/Memoization)\n * @returns a reference to the wrapped function. Assign this reference to a variable\n * and invoke in the same manner as a function.\n */\nconst memoize = (fn) => {\n  // A hopefully unique object property name/key!\n  const id = 'id_Z?7kQ;x8j!';\n  const cache = {};\n  return (arg) => {\n    if (!arg[id]) {\n      // Attach a random id property to this object\n      //  eslint-disable-next-line no-param-reassign\n      arg[id] = Math.random().toString(16).slice(2);\n    }\n\n    if (!(arg[id] in cache)) {\n      cache[arg[id]] = fn(arg);\n      trace(`memoize:caching id ${arg[id]}`);\n    }\n\n    return cache[arg[id]];\n  };\n};\n\n/**\n * **removeClass** - remove a [CSS](https://en.wikipedia.org/wiki/CSS) class from a\n * [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) element.\n * @param {*} element the element (object reference)\n * @param {*} className the class to add (string)\n */\nfunction removeClass(element, className) {\n  element.classList.remove(className);\n}\n\n/**\n * setLetter - Set the _source_ letter at _index_ to _newLetter_. Pad _source_ if required.\n * @param {*} source string to be modified\n * @param {*} index target position in _source_\n * @param {*} newLetter replacement letter\n * @returns\n */\nfunction setLetter(source, index, newLetter) {\n  let result = source === null || source === undefined ? '' : source;\n  result = result.padEnd(index + 1, ' ');\n  return replaceStrAt(result, index, newLetter);\n}\n\n/**\n * **toggleClass** - _toggle_(add/remove) a [CSS](https://en.wikipedia.org/wiki/CSS) class on a\n * [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) element.\n * @param {*} element the element (object reference)\n * @param {*} className the class to add (string)\n */\nfunction toggleClass(element, className) {\n  element.classList.toggle(className);\n}\n\n/**\n * toHexString - convert an object to a hexadecimal string\n * @param {} obj - object to be converted\n * @returns string of hexadecimal digits\n */\nconst toHexString = (obj) => {\n  // Fails for circular objects\n  return `0x${[...JSON.stringify(obj)]\n    .map((c, i) => str.charCodeAt(i).toString(16))\n    .join('')}`;\n};\n\n// module scope variable to toggle log tracing\nlet tracingEnabled = false;\n\n/**\n * **tracing** - enable or disable console logging\n * @param {*} enabled logging is on/off\n */\nconst tracing = (enabled) => {\n  tracingEnabled = enabled;\n};\n\n/**\n * trace - console logging\n * @param action - 'log', 'warn' or 'error'. Default is 'log'\n * @param message - string to be logged\n */\nconst trace = (message, action = 'log') => {\n  if (tracingEnabled) {\n    assert(\n      ['log', 'warn', 'error'].includes(action),\n      `Unsupported action'${action}'.`,\n    );\n    console[action](message);\n  }\n};\n\n// https://dev.to/adancarrasco/implementing-pub-sub-in-javascript-3l2e\n// Topics should only be modified from the eventRouter itself (return value of newPubSub)\nconst newPubSub = () => {\n  const topics = {};\n  const hOP = topics.hasOwnProperty;\n\n  return {\n    publish: (topic, info) => {\n      // No topics\n      if (!hOP.call(topics, topic)) return;\n\n      // Emit the message to any of the receivers\n      topics[topic].forEach((item) => {\n        // Send any arguments if specified\n        item(info !== undefined ? info : {});\n      });\n    },\n    subscribe: (topic, callback) => {\n      // Create the array of topics if not initialized yet\n      if (!hOP.call(topics, topic)) topics[topic] = [];\n\n      // We define the index where this receiver is stored in the topics array\n      const index = topics[topic].push(callback) - 1;\n\n      // When we subscribe we return an object to later remove the subscription\n      return {\n        remove: () => {\n          delete topics[topic][index];\n        },\n      };\n    },\n  };\n};\n\nfunction newEnum(values) {\n  const enumeration = {};\n  for (const val of values) {\n    enumeration[val] = val;\n  }\n  return Object.freeze(enumeration);\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/helpers.mjs?");

/***/ }),

/***/ "./src/index.mjs":
/*!***********************!*\
  !*** ./src/index.mjs ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CrosswordsJS\": () => (/* binding */ CrosswordsJS)\n/* harmony export */ });\n/* harmony import */ var _crossword_model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crossword-model.mjs */ \"./src/crossword-model.mjs\");\n/* harmony import */ var _crossword_controller_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crossword-controller.mjs */ \"./src/crossword-controller.mjs\");\n\n\n\n//  Define our public API.\nconst CrosswordsJS = {\n  compileCrossword: _crossword_model_mjs__WEBPACK_IMPORTED_MODULE_0__.newCrosswordModel,\n  Controller: _crossword_controller_mjs__WEBPACK_IMPORTED_MODULE_1__.CrosswordController,\n};\n\n//  If we are in the browser, add the API to the global scope.\nif (typeof window !== 'undefined') {\n  window.CrosswordsJS = CrosswordsJS;\n}\n\n\n\n\n//# sourceURL=webpack://crosswords-js/./src/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.mjs");
/******/ 	
/******/ })()
;